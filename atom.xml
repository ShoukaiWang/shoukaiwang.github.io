<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SKのBlog</title>
  
  <subtitle>King</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shoukaiwang.github.io/"/>
  <updated>2020-07-23T09:19:48.085Z</updated>
  <id>https://shoukaiwang.github.io/</id>
  
  <author>
    <name>SK Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://shoukaiwang.github.io/posts/16107/"/>
    <id>https://shoukaiwang.github.io/posts/16107/</id>
    <published>2020-07-23T09:19:48.085Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://shoukaiwang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://shoukaiwang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL的渲染技巧-正背面剔除</title>
    <link href="https://shoukaiwang.github.io/posts/ecffcb82/"/>
    <id>https://shoukaiwang.github.io/posts/ecffcb82/</id>
    <published>2020-07-20T10:07:40.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<p>今天通过一个小案例，来讲解OpenGL的正背面剔除以及深度测试的应用。</p><h1 id="圆环的绘制"><a href="#圆环的绘制" class="headerlink" title="圆环的绘制"></a>圆环的绘制</h1><p>我们使用<code>GLTools</code>中的<code>void gltMakeTorus(GLTriangleBatch&amp; torusBatch, GLfloat majorRadius, GLfloat minorRadius, GLint numMajor, GLint numMinor)</code>方法，简单实现一下圆环的绘制。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//  main.cpp</span><span class="token comment" spellcheck="true">//  OpenGLDemo</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//  Created by SK on 2020/7/3.</span><span class="token comment" spellcheck="true">//  Copyright © 2020 SK. All rights reserved.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLShaderManager.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLTools.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GLUT/GLUT.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLMatrixStack.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLFrame.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLFrustum.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLGeometryTransform.h"</span></span><span class="token comment" spellcheck="true">//定义一个，着色管理器</span>GLShaderManager shaderManager<span class="token punctuation">;</span>GLFrame viewFrame<span class="token punctuation">;</span>GLFrustum viewFrustum<span class="token punctuation">;</span>GLTriangleBatch torusBatch<span class="token punctuation">;</span>GLMatrixStack modelViewMatix<span class="token punctuation">;</span>GLMatrixStack projectionMatrix<span class="token punctuation">;</span>GLGeometryTransform transformPipeline<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">changeSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    viewFrustum<span class="token punctuation">.</span><span class="token function">SetPerspective</span><span class="token punctuation">(</span><span class="token number">35.0f</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">float</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    projectionMatrix<span class="token punctuation">.</span><span class="token function">LoadMatrix</span><span class="token punctuation">(</span>viewFrustum<span class="token punctuation">.</span><span class="token function">GetProjectionMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    transformPipeline<span class="token punctuation">.</span><span class="token function">SetMatrixStacks</span><span class="token punctuation">(</span>modelViewMatix<span class="token punctuation">,</span> projectionMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">renderScene</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT <span class="token operator">|</span> GL_STENCIL_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    GLfloat vRed<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    modelViewMatix<span class="token punctuation">.</span><span class="token function">PushMatrix</span><span class="token punctuation">(</span>viewFrame<span class="token punctuation">)</span><span class="token punctuation">;</span>    shaderManager<span class="token punctuation">.</span><span class="token function">UseStockShader</span><span class="token punctuation">(</span>GLT_SHADER_DEFAULT_LIGHT<span class="token punctuation">,</span> transformPipeline<span class="token punctuation">.</span><span class="token function">GetModelViewMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transformPipeline<span class="token punctuation">.</span><span class="token function">GetProjectionMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vRed<span class="token punctuation">)</span><span class="token punctuation">;</span>    torusBatch<span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    modelViewMatix<span class="token punctuation">.</span><span class="token function">PopMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutSwapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">specialKeys</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_UP<span class="token punctuation">)</span>        viewFrame<span class="token punctuation">.</span><span class="token function">RotateWorld</span><span class="token punctuation">(</span><span class="token function">m3dDegToRad</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_DOWN<span class="token punctuation">)</span>        viewFrame<span class="token punctuation">.</span><span class="token function">RotateWorld</span><span class="token punctuation">(</span><span class="token function">m3dDegToRad</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_LEFT<span class="token punctuation">)</span>        viewFrame<span class="token punctuation">.</span><span class="token function">RotateWorld</span><span class="token punctuation">(</span><span class="token function">m3dDegToRad</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_RIGHT<span class="token punctuation">)</span>        viewFrame<span class="token punctuation">.</span><span class="token function">RotateWorld</span><span class="token punctuation">(</span><span class="token function">m3dDegToRad</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutPostRedisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">setupRC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shaderManager<span class="token punctuation">.</span><span class="token function">InitializeStockShaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    viewFrame<span class="token punctuation">.</span><span class="token function">MoveForward</span><span class="token punctuation">(</span><span class="token number">7.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">gltMakeTorus</span><span class="token punctuation">(</span>torusBatch<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glPointSize</span><span class="token punctuation">(</span><span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">gltSetWorkingDirectory</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_DOUBLE <span class="token operator">|</span> GLUT_RGBA <span class="token operator">|</span> GLUT_DEPTH <span class="token operator">|</span> GLUT_STENCIL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"OpenGL Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutReshapeFunc</span><span class="token punctuation">(</span>changeSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>renderScene<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutSpecialFunc</span><span class="token punctuation">(</span>specialKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>    GLenum err <span class="token operator">=</span> <span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> GLEW_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"glew error: %s\n"</span><span class="token punctuation">,</span> <span class="token function">glewGetErrorString</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setupRC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实现的效果如下图所示：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-a4db983cc2572c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>看起来是一个很漂亮的圆环，当我们缓慢的转到圆环，我们会看到下面的情况：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-aaf0404b2c61b46d.gif?imageMogr2/auto-orient/strip" alt="2020-07-17 14-45-39.2020-07-17 14_51_33.gif"></p><p>No，为什么会有这些黑色的出行？为什么开始显示的好好的，一转动就出现了这样的情况？</p><p>其实在绘制3D场景的时候，我们需要决定哪些部分是对观察者可见的，哪些部分是对观察者不可见的。对于不可见的部分,应该及早丢弃。例如在一个不透明的墙壁后，就不应该渲染。这种情况叫做<code>隐藏面消除(Hidden surface elimination)</code>。</p><h1 id="消除隐藏面的解决方案"><a href="#消除隐藏面的解决方案" class="headerlink" title="消除隐藏面的解决方案"></a>消除隐藏面的解决方案</h1><h2 id="油画算法"><a href="#油画算法" class="headerlink" title="油画算法"></a>油画算法</h2><p>先绘制场景中的离观察者较远的物体，在绘制较近的物体。<br>例如下面的图例：先绘制红色部分，在绘制黄色部门，最后绘制灰色部门，即可解决隐藏面消除的问题。<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-f9c67813fca29d3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="油画算法的弊端"><a href="#油画算法的弊端" class="headerlink" title="油画算法的弊端"></a>油画算法的弊端</h4><p>如果场景里的物体出现了交叉叠加的情况，油画算法将无法处理。</p><h2 id="正背面剔除（Face-Culling）"><a href="#正背面剔除（Face-Culling）" class="headerlink" title="正背面剔除（Face Culling）"></a>正背面剔除（Face Culling）</h2><p>当我们从任意一个方向去观察一个3D图形，最多可以看到几个面？答案是最多3个面，从一个立方体的任意位置和方向上看，不可能看到多余3个面，那么我们在绘制的过程中，为何要多余的绘制那些看不到的面呢？如果我们能以某种方式去丢弃这部分数据，OpenGL在渲染的性能上可以提高50%。</p><p>OpenGL可以做到检查所有正面朝向观察者的面，并渲染它们，从而丢弃背面朝向的面。这样可以节约片元着色器的性能。</p><blockquote><p>正面和背面是有三角形的顶点定义顺序和观察者⽅向共同决定的。随着观察者的⻆度方向的改变，正面背面也会跟着改变。</p></blockquote><p>在OpenGL中开启正背面剔除的相关方法如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//开启表面剔除(默认背面剔除)</span><span class="token keyword">void</span> <span class="token function">glEnable</span><span class="token punctuation">(</span>GL_CULL_FACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭表面剔除(默认背面剔除)</span><span class="token keyword">void</span> <span class="token function">glDisable</span><span class="token punctuation">(</span>GL_CULL_FACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户选择剔除那个面(正面/背面)</span><span class="token comment" spellcheck="true">//mode参数为: GL_CW,GL_CCW,默认值:GL_CCW</span><span class="token keyword">void</span> <span class="token function">glCullFace</span><span class="token punctuation">(</span>GLenum mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//mode参数为: GL_FRONT,GL_BACK,GL_FRONT_AND_BACK ,默认GL_BACK 用户指定绕序那个为正面</span><span class="token keyword">void</span> <span class="token function">glFrontFace</span><span class="token punctuation">(</span>GLenum mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//剔除正面实现例1</span><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_BACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glFrontFace</span><span class="token punctuation">(</span>GL_CW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//剔除正⾯实现例2</span><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_FRONT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们开启正背面剔除功能，来看一下实现效果：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-6332d45bcb830341.gif?imageMogr2/auto-orient/strip" alt="2020-07-17 16-25-01.2020-07-17 16_25_33.gif"><br>开启了正背面剔除功能，我们已经基本的达到了预期的展示效果，但是当我们继续旋转时发现，出现了新的问题，如何解决这样的问题呢？这就引出了一个新的概念 <strong>深度测试</strong></p><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>那么什么是深度？<br><strong>深度</strong> 其实就是该像素点在3D世界中距离摄像机的距离，也就是<code>Z</code>值。<br><strong>深度缓存区</strong>就是一块内存区域，专门存储着每个像素点(绘制在屏幕上的)深度值。深度值(Z值)越⼤， 则离摄像机就越远。</p><p>在不使⽤深度测试的时候，如果我们先绘制⼀个距离比较近的物体，再绘制距离较远的物体,则距离远的位图因为后绘制，会把距离近的物体覆盖掉。有了深度缓冲区后，绘制物体的顺序就不那么􏰁要了。实际上，只要存在深度缓冲区，OpenGL 都会把像素的深度值写入到缓冲区中。除⾮调⽤ <code>glDepthMask(GL_FALSE)</code>来禁⽌写⼊。</p><p>未完待续…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天通过一个小案例，来讲解OpenGL的正背面剔除以及深度测试的应用。&lt;/p&gt;
&lt;h1 id=&quot;圆环的绘制&quot;&gt;&lt;a href=&quot;#圆环的绘制&quot; class=&quot;headerlink&quot; title=&quot;圆环的绘制&quot;&gt;&lt;/a&gt;圆环的绘制&lt;/h1&gt;&lt;p&gt;我们使用&lt;code&gt;GLToo
      
    
    </summary>
    
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/categories/OpenGL/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>探寻autoreleasepool</title>
    <link href="https://shoukaiwang.github.io/posts/2d6c78da/"/>
    <id>https://shoukaiwang.github.io/posts/2d6c78da/</id>
    <published>2020-07-12T00:52:37.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h1><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    @autoreleasepool <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们通过执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fno-objc-arc  main.m</code>，将上述代码转换成C++</p><pre class=" language-c++"><code class="language-c++">struct __AtAutoreleasePool {  __AtAutoreleasePool() {      atautoreleasepoolobj = objc_autoreleasePoolPush();  }  ~__AtAutoreleasePool() {      objc_autoreleasePoolPop(atautoreleasepoolobj);  }  void * atautoreleasepoolobj;};int main(int argc, const char * argv[]) {    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;    }    return 0;}</code></pre><p>通过C++代码我们发现，autoreleasepool是由objc_autoreleasePoolPush 和 objc_autoreleasePoolPop方法构成的一个结构体。</p><p>接下来我们来研究一下<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code>方法的具体实现。</p><p>参照苹果开源代码，我们找到了objc_autoreleasePoolPush和objc_autoreleasePoolPop的具体实现。（<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4</a>/）</p><pre class=" language-c++"><code class="language-c++">void *objc_autoreleasePoolPush(void){    return AutoreleasePoolPage::push();}voidobjc_autoreleasePoolPop(void *ctxt){    AutoreleasePoolPage::pop(ctxt);}static inline id autorelease(id obj)    {        ASSERT(obj);        ASSERT(!obj->isTaggedPointer());        id *dest __unused = autoreleaseFast(obj);        ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);        return obj;    }static inline id *autoreleaseFast(id obj)    {        AutoreleasePoolPage *page = hotPage();        if (page && !page->full()) {            return page->add(obj);        } else if (page) {            return autoreleaseFullPage(obj, page);        } else {            return autoreleaseNoPage(obj);        }    }static inline void *push()     {        id *dest;        if (slowpath(DebugPoolAllocation)) {            // Each autorelease pool starts on a new pool page.            dest = autoreleaseNewPage(POOL_BOUNDARY);        } else {            dest = autoreleaseFast(POOL_BOUNDARY);        }        ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);        return dest;    }static void    popPage(void *token, AutoreleasePoolPage *page, id *stop)    {        if (allowDebug && PrintPoolHiwat) printHiwat();        page->releaseUntil(stop);        // memory: delete empty children        if (allowDebug && DebugPoolAllocation  &&  page->empty()) {            // special case: delete everything during page-per-pool debugging            AutoreleasePoolPage *parent = page->parent;            page->kill();            setHotPage(parent);        } else if (allowDebug && DebugMissingPools  &&  page->empty()  &&  !page->parent) {            // special case: delete everything for pop(top)            // when debugging missing autorelease pools            page->kill();            setHotPage(nil);        } else if (page->child) {            // hysteresis: keep one empty child if page is more than half full            if (page->lessThanHalfFull()) {                page->child->kill();            }            else if (page->child->child) {                page->child->child->kill();            }        }    }</code></pre><p>通过源码我们发现自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code><br>调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的。</p><h1 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构"></a>AutoreleasePoolPage的结构</h1><pre class=" language-c++"><code class="language-c++">struct AutoreleasePoolPageData{    magic_t const magic;    __unsafe_unretained id *next;    pthread_t const thread;    AutoreleasePoolPage * const parent;    AutoreleasePoolPage *child;    uint32_t const depth;    uint32_t hiwat;};class AutoreleasePoolPage : private AutoreleasePoolPageData {}</code></pre><p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址。</p><p>所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起。</p><ul><li>调用push方法会将一个<code>POOL_BOUNDARY</code>入栈，并且返回其存放的内存地址</li><li>调用pop方法时传入一个<code>POOL_BOUNDARY</code>的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个<code>POOL_BOUNDARY</code></li><li>id *next指向了下一个能存放autorelease对象地址的区域  <blockquote><p>可以通过以下私有函数来查看自动释放池的情况<br><code>extern void _objc_autoreleasePoolPrint(void);</code></p></blockquote></li></ul><h1 id="autoreleasepool与RunLoop的关系"><a href="#autoreleasepool与RunLoop的关系" class="headerlink" title="autoreleasepool与RunLoop的关系"></a>autoreleasepool与RunLoop的关系</h1><pre class=" language-shell"><code class="language-shell">(lldb) po [NSRunLoop mainRunLoop]<CFRunLoop 0x6000008f0300 [0x7fff8062d610]>{wakeup port = 0x2207, stopped = false, ignoreWakeUps = false, current mode = kCFRunLoopDefaultMode,common modes = <CFBasicHash 0x600003aacf60 [0x7fff8062d610]>{type = mutable set, count = 2,entries =>    0 : <CFString 0x7fff8692c2c0 [0x7fff8062d610]>{contents = "UITrackingRunLoopMode"}    2 : <CFString 0x7fff806408e0 [0x7fff8062d610]>{contents = "kCFRunLoopDefaultMode"}},common mode items = <CFBasicHash 0x600003aad230 [0x7fff8062d610]>{type = mutable set, count = 14,entries =>    20 : <CFRunLoopObserver 0x6000005f83c0 [0x7fff8062d610]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff48c84b28), context = <CFArray 0x600003abfd50 [0x7fff8062d610]>{type = mutable-small, count = 1, values = (    0 : <0x7f9ec100f038>)}}    22 : <CFRunLoopObserver 0x6000005f8460 [0x7fff8062d610]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff48c84b28), context = <CFArray 0x600003abfd50 [0x7fff8062d610]>{type = mutable-small, count = 1, values = (    0 : <0x7f9ec100f038>)}}}</code></pre><p>通过<code>mainRunLoop</code>的打印信息，我们发现在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><pre class=" language-c++"><code class="language-c++">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {    kCFRunLoopEntry = (1UL << 0),    kCFRunLoopBeforeTimers = (1UL << 1),    kCFRunLoopBeforeSources = (1UL << 2),    kCFRunLoopBeforeWaiting = (1UL << 5),    kCFRunLoopAfterWaiting = (1UL << 6),    kCFRunLoopExit = (1UL << 7),    kCFRunLoopAllActivities = 0x0FFFFFFFU};</code></pre><ol><li><p>第一个 Observer 的activities = 0x1，即监听kCFRunLoopEntry事件，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p></li><li><p>第二个 Observer 的activities = 0xa0，即kCFRunLoopBeforeWaiting &amp; kCFRunLoopExit两个事件</p></li></ol><ul><li>kCFRunLoopBeforeWaiting时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的自动释放池并创建新池；</li><li>kCFRunLoopExit时调用 _objc_autoreleasePoolPop() 来释放自动释放池。其order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据苹果官方文档中对 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="noopener">Using Autorelease Pool Blocks</a> 的描述，我们知道在下面三种情况下是需要我们手动添加 autoreleasepool的：</p><ul><li>如果你编写的程序不是基于 UI 框架的，比如说命令行工具；</li><li>如果你编写的循环中创建了大量的临时对象；</li><li>如果你创建了一个辅助线程。当你的线程执行时，你必须尽可能快的自己创建自动释放池;</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;底层结构&quot;&gt;&lt;a href=&quot;#底层结构&quot; class=&quot;headerlink&quot; title=&quot;底层结构&quot;&gt;&lt;/a&gt;底层结构&lt;/h1&gt;&lt;pre class=&quot; language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;to
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS中离屏渲染探索</title>
    <link href="https://shoukaiwang.github.io/posts/303a73ce/"/>
    <id>https://shoukaiwang.github.io/posts/303a73ce/</id>
    <published>2020-07-11T11:37:51.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是离屏渲染？"><a href="#什么是离屏渲染？" class="headerlink" title="什么是离屏渲染？"></a>什么是离屏渲染？</h1><p>离屏渲染（offscreen-rendering）顾名思义为屏幕外的渲染，即渲染的结果不会直接呈现到当前屏幕上，而是等待合适的时机才会被显示。</p><p>正常情况下，在当前屏幕显示的内容，由 GPU 渲染完成后放到当前屏幕的帧缓存区，不需要额外的渲染空间。</p><p>假如 GPU 因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p><h1 id="离屏渲染的过程"><a href="#离屏渲染的过程" class="headerlink" title="离屏渲染的过程"></a>离屏渲染的过程</h1><p>通常的渲染流程是这样的<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-8e3671bcd114693a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在正常情况下，经过CPU的计算以及GPU的渲染之后，不停地将内容渲染完成放入<code>Frame Buffer</code>中帧缓存区，随后视频控制器会读取帧缓存区的数据，经过数模转换，再逐行显示到屏幕上</p><p>出现离屏渲染的渲染流程：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-4c0629f864bc80eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>与普通情况下 GPU 直接将渲染好的内容放入<code>Frame Buffer</code>中不同，在某些特殊情况下，需要先额外创建离屏渲染缓冲区 <code>offscreen Buffer</code>，将提前渲染好的内容放入其中，等到合适的时机再将 offscreen Buffer 中的内容进一步叠加、渲染，最后将结果切换到 Frame Buffer 中。</p><h1 id="离屏渲染的利弊"><a href="#离屏渲染的利弊" class="headerlink" title="离屏渲染的利弊"></a>离屏渲染的利弊</h1><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>特殊的渲染效果：使用额外的离屏缓冲区（offscreen butter)保存中间状态，最后叠加、处理后绘制在屏幕上，这样就不得不使用离屏渲染</li><li>效率优势：需要多次使用的效果，提前渲染存入离屏缓冲区，然后复用来提高效率。<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4></li><li>内存开支：开辟离屏缓冲区（大小不超过2.5倍屏幕像素大小）</li><li>时间和性能开支：从离屏缓冲区拷贝数据到帧缓冲区，上下文切换耗性能，容易出现掉帧的情况</li></ul><h1 id="常见的触发离屏渲染的情况"><a href="#常见的触发离屏渲染的情况" class="headerlink" title="常见的触发离屏渲染的情况"></a>常见的触发离屏渲染的情况</h1><ul><li>使用了 mask 的 layer (layer.mask)</li><li>需要进行裁剪的 layer (layer.masksToBounds /view.clipsToBounds)</li><li>设置了组透明度为 YES，并且透明度不为 1 的layer (layer.allowsGroupOpacity/ layer.opacity)</li><li>添加了投影的 layer (layer.shadow*)</li><li>采用了光栅化的 layer (layer.shouldRasterize)<blockquote><p>不过使用光栅化的时候需要注意以下几点：</p><ol><li>如果layer不能被复用，则不必打开光栅化</li><li>如果layer不是静态的，需要被频繁修改，如处于动画中，那开启离屏渲染反而会影响效率<ol start="3"><li>离屏渲染缓存内容有时间限制，缓存内容100ms内没有被使用，那么它就会丢弃，无法进行复用了</li></ol></li><li>离屏渲染缓存空间有限，不能超过2.5倍屏幕像素大小</li></ol></blockquote></li><li>绘制了文字的 layer (UILabel, CATextLayer, Core Text 等)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是离屏渲染？&quot;&gt;&lt;a href=&quot;#什么是离屏渲染？&quot; class=&quot;headerlink&quot; title=&quot;什么是离屏渲染？&quot;&gt;&lt;/a&gt;什么是离屏渲染？&lt;/h1&gt;&lt;p&gt;离屏渲染（offscreen-rendering）顾名思义为屏幕外的渲染，即渲染的结果不会直
      
    
    </summary>
    
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/categories/OpenGL/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>探寻iOS多线程</title>
    <link href="https://shoukaiwang.github.io/posts/6322cf7d/"/>
    <id>https://shoukaiwang.github.io/posts/6322cf7d/</id>
    <published>2020-07-10T15:15:25.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS中的常见多线程方案"><a href="#iOS中的常见多线程方案" class="headerlink" title="iOS中的常见多线程方案"></a>iOS中的常见多线程方案</h1><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7a37d617f4fd1042.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><p>GCD中有2个用来执行任务的函数</p><ul><li>用同步的方式执行任务<br>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</li><li>用异步的方式执行任务<br>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</li></ul><p>GCD源码：<a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">https://github.com/apple/swift-corelibs-libdispatch</a></p><h4 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h4><p>GCD的队列可以分为2大类型</p><ul><li>并发队列（Concurrent Dispatch Queue）<br>可以让多个任务并发执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步函数下才有效</li><li>串行队列（Serial Dispatch Queue）<br>让任务一个接着一个地执行</li></ul><p><code>同步</code>和<code>异步</code>主要影响：能不能开启新的线程<br>同步：在<code>当前线程</code>中执行任务，<code>不具备</code>开启新线程的能力<br>异步：在<code>新的线程</code>中执行任务，<code>具备</code>开启新线程的能力</p><p><code>并发</code>和<code>串行</code>主要影响：任务的执行方式<br>并发：多个任务并发执行<br>串行：一个任务执行完毕后，再执行下一个任务</p><blockquote><p>使用<code>sync</code>函数往<code>当前串行</code>队列中添加任务，会卡住当前的串行队列（产生死锁）</p></blockquote><h1 id="GCD-Group"><a href="#GCD-Group" class="headerlink" title="GCD Group"></a>GCD Group</h1><p>下面场景如何实现？</p><ul><li><p>异步并发执行任务1、任务2</p></li><li><p>等任务1、任务2都执行完毕后，再回到主线程执行任务3</p><pre><code>dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^{     NSLog(@"Task-1"); }); dispatch_group_async(group, queue, ^{     NSLog(@"Task-2"); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{     NSLog(@"Task-3"); });</code></pre></li></ul><h1 id="iOS中的线程同步方案"><a href="#iOS中的线程同步方案" class="headerlink" title="iOS中的线程同步方案"></a>iOS中的线程同步方案</h1><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。<br>常见的解决方案：使用线程同步技术。<br>iOS中，常见的线程锁有以下几个：</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源<br>目前已经不再安全，可能会出现优先级反转问题<br>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁。</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持<br>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等<br>需要导入头文件#import &lt;os/lock.h&gt;</p><h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><p>mutex叫做<code>互斥锁</code>，等待锁的线程会处于休眠状态<br>需要导入头文件#import &lt;pthread.h&gt;</p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><p>semaphore叫做”信号量”<br>信号量的初始值，可以用来控制线程并发访问的最大数量<br>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p><code>@synchronized</code>是对mutex递归锁的封装<br>源码查看：objc4中的objc-sync.mm文件<br><code>@synchronized(obj)</code>内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p><h1 id="iOS线程同步方案性能比较"><a href="#iOS线程同步方案性能比较" class="headerlink" title="iOS线程同步方案性能比较"></a>iOS线程同步方案性能比较</h1><p>性能从高到低排序<br>os_unfair_lock<br>OSSpinLock<br>dispatch_semaphore<br>pthread_mutex<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSCondition<br>pthread_mutex(recursive)<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized</p><h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1><p>-atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁<br>可以参考源码objc4的objc-accessors.mm<br>它并不能保证使用属性的过程是线程安全的</p><h1 id="iOS中的读写安全方案"><a href="#iOS中的读写安全方案" class="headerlink" title="iOS中的读写安全方案"></a>iOS中的读写安全方案</h1><ol><li>pthread_rwlock<blockquote><p>等待锁的线程会进入休眠</p></blockquote></li><li>dispatch_barrier_async<blockquote><p>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的<br>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</p></blockquote></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS中的常见多线程方案&quot;&gt;&lt;a href=&quot;#iOS中的常见多线程方案&quot; class=&quot;headerlink&quot; title=&quot;iOS中的常见多线程方案&quot;&gt;&lt;/a&gt;iOS中的常见多线程方案&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; d
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>探寻runLoop</title>
    <link href="https://shoukaiwang.github.io/posts/66966108/"/>
    <id>https://shoukaiwang.github.io/posts/66966108/</id>
    <published>2020-07-10T11:44:26.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，RunLoop就是运行循环，在程序运行过程中循环做一些事情。<br>应用的一些场景：</p><ul><li>定时器（Timer）、PerformSelector</li><li>GCD Async Main Queue</li><li>事件响应、手势识别、界面刷新</li><li>网络请求</li><li>AutoreleasePool</li><li>控制线程生命周期（线程保活）</li><li>监控应用卡顿</li><li>性能优化</li></ul><p>iOS中有2套API来访问和使用RunLoop</p><ul><li>Foundation：<code>NSRunLoop</code></li><li>Core Foundation：<code>CFRunLoopRef</code></li></ul><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象，NSRunLoop是基于CFRunLoopRef的一层OC包装，CFRunLoopRef是开源的<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></p><h1 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h1><ul><li>每条线程都有唯一的一个与之对应的RunLoop对象</li><li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li><li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li><li>RunLoop会在线程结束时销毁</li><li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li></ul><h1 id="RunLoop相关的类"><a href="#RunLoop相关的类" class="headerlink" title="RunLoop相关的类"></a>RunLoop相关的类</h1><p>Core Foundation中关于RunLoop的5个类</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><pre class=" language-c++"><code class="language-c++">typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode {    CFRuntimeBase _base;    CFStringRef _name;    CFMutableSetRef _sources0;    CFMutableSetRef _sources1;    CFMutableArrayRef _observers;    CFMutableArrayRef _timers;};struct __CFRunLoop {    pthread_t _pthread;    CFMutableSetRef _commonModes;    CFMutableSetRef _commonModeItems;    CFRunLoopModeRef _currentMode;    CFMutableSetRef _modes;};</code></pre><h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><ul><li>CFRunLoopModeRef代表RunLoop的运行模式</li><li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</li><li>RunLoop启动时只能选择其中一个Mode，作为currentMode</li><li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入</li><li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li><li>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</li></ul><p>常见的2种Mode</p><ul><li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</li><li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li></ul><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><pre class=" language-c++"><code class="language-c++">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {    kCFRunLoopEntry = (1UL << 0),    kCFRunLoopBeforeTimers = (1UL << 1),    kCFRunLoopBeforeSources = (1UL << 2),    kCFRunLoopBeforeWaiting = (1UL << 5),    kCFRunLoopAfterWaiting = (1UL << 6),    kCFRunLoopExit = (1UL << 7),    kCFRunLoopAllActivities = 0x0FFFFFFFU};</code></pre><p>可以添加Observer监听RunLoop的所有状态</p><pre class=" language-c++"><code class="language-c++">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {        switch (activity) {            case kCFRunLoopEntry:                NSLog(@"kCFRunLoopEntry");                break;            case kCFRunLoopBeforeTimers:                NSLog(@"kCFRunLoopBeforeTimers");                break;            case kCFRunLoopBeforeSources:                NSLog(@"kCFRunLoopBeforeSources");                break;            case kCFRunLoopBeforeWaiting:                NSLog(@"kCFRunLoopBeforeWaiting");                break;            case kCFRunLoopAfterWaiting:                NSLog(@"kCFRunLoopAfterWaiting");                break;            case kCFRunLoopExit:                NSLog(@"kCFRunLoopExit");                break;            case kCFRunLoopAllActivities:                NSLog(@"kCFRunLoopAllActivities");                break;        }    });    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopDefaultMode);    CFRelease(observer);</code></pre><h1 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h1><ol><li>通知Observers：进入Loop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks</li><li>处理Source0（可能会再次处理Blocks）</li><li>如果存在Source1，就跳转到第8步</li><li>通知Observers：开始休眠（等待消息唤醒）</li><li>通知Observers：结束休眠（被某个消息唤醒）<ul><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ul></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作<ul><li>回到第02步</li><li>退出Loop</li></ul></li><li>通知Observers：退出Loop</li></ol><h1 id="RunLoop休眠的实现原理"><a href="#RunLoop休眠的实现原理" class="headerlink" title="RunLoop休眠的实现原理"></a>RunLoop休眠的实现原理</h1><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-c554f50c0bf115c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;顾名思义，RunLoop就是运行循环，在程序运行过程中循环做一些事情。&lt;br&gt;应用的一些场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时器（Timer）、PerformSelector&lt;/li&gt;
&lt;li&gt;GCD Async Main Queue&lt;/li&gt;
&lt;li&gt;事件响应、手势识别、
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
      <category term="runloop" scheme="https://shoukaiwang.github.io/tags/runloop/"/>
    
  </entry>
  
  <entry>
    <title>探寻block</title>
    <link href="https://shoukaiwang.github.io/posts/d97e40db/"/>
    <id>https://shoukaiwang.github.io/posts/d97e40db/</id>
    <published>2020-07-09T16:28:06.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="block的本质"><a href="#block的本质" class="headerlink" title="block的本质"></a>block的本质</h1><p>block本质上也是一个OC对象，它内部也有个isa指针。<br>block是封装了函数调用以及函数调用环境的OC对象。</p><pre class=" language-objective-c"><code class="language-objective-c">////  Created by SK on 2020/7/7.//  Copyright © 2020 SK. All rights reserved.//#import <Foundation/Foundation.h>#import "Person.h"NSString *name = @"jack";int main(int argc, const char * argv[]) {    @autoreleasepool {        int age = 20;        static int sex = 0;        Person *person1 = [[Person alloc] init];        Person *person2 = [[Person alloc] init];        Person *person3 = [[Person alloc] init];        __strong Person *strongPerson = person1;        __weak Person *weakPerson = person2;        __block Person *blockPerson = person3;        void (^block)(void) = ^{            NSLog(@"%d-%d-%@", age, sex, name);            [strongPerson run];            [weakPerson run];            [blockPerson run];        };        block();    }    return 0;}</code></pre><p>我们通过执行<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-9.0 main.m</code><br>编译一下上述代码，来看一下block的底层结构</p><pre class=" language-c++"><code class="language-c++">struct __block_impl {  void *isa;  int Flags;  int Reserved;  void *FuncPtr;};struct __Block_byref_blockPerson_0 {  void *__isa;__Block_byref_blockPerson_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); Person *__strong blockPerson;};struct __main_block_impl_0 {  struct __block_impl impl;  struct __main_block_desc_0* Desc;  int age;  int *sex;  Person *__strong strongPerson;  Person *__weak weakPerson;  __Block_byref_blockPerson_0 *blockPerson; // by ref}static void __main_block_func_0(struct __main_block_impl_0 *__cself) {  __Block_byref_blockPerson_0 *blockPerson = __cself->blockPerson; // bound by ref  int age = __cself->age; // bound by copy  int *sex = __cself->sex; // bound by copy  Person *__strong strongPerson = __cself->strongPerson; // bound by copy  Person *__weak weakPerson = __cself->weakPerson; // bound by copy            NSLog((NSString *)&__NSConstantStringImpl__var_folders_h6_tk2fn5rd5r92tqhsv84hkj540000gn_T_main_e976c4_mi_1, age, (*sex), name);            ((void (*)(id, SEL))(void *)objc_msgSend)((id)strongPerson, sel_registerName("run"));            ((void (*)(id, SEL))(void *)objc_msgSend)((id)weakPerson, sel_registerName("run"));            ((void (*)(id, SEL))(void *)objc_msgSend)((id)(blockPerson->__forwarding->blockPerson), sel_registerName("run"));}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->strongPerson, (void*)src->strongPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&dst->weakPerson, (void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&dst->blockPerson, (void*)src->blockPerson, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->strongPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src->weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src->blockPerson, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 {  size_t reserved;  size_t Block_size;  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);  void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char * argv[]) {    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;         int age = 20;        static int sex = 0;        Person *person1 = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init"));        Person *person2 = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init"));        Person *person3 = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init"));        __attribute__((objc_ownership(strong))) Person *strongPerson = person1;        __attribute__((objc_ownership(weak))) Person *weakPerson = person2;        __attribute__((__blocks__(byref))) __Block_byref_blockPerson_0 blockPerson = {(void*)0,(__Block_byref_blockPerson_0 *)&blockPerson, 33554432, sizeof(__Block_byref_blockPerson_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, person3};        void (*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age, &sex, strongPerson, weakPerson, (__Block_byref_blockPerson_0 *)&blockPerson, 570425344));        ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);    }    return 0;}</code></pre><p>从上述代码可以看出，block的底层结构如下：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-4880f7d553d49551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Block底层结构.png"></p><h1 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h1><p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。</p><ul><li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）<br>没有访问auto变量</li><li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）<br>访问了auto变量</li><li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）<br><strong>NSStackBlock</strong>调用了copy</li></ul><h1 id="block的变量捕获"><a href="#block的变量捕获" class="headerlink" title="block的变量捕获"></a>block的变量捕获</h1><p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-a99b237c33292d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>_NSConcreteGlobalBlock类型的block调动copy，无变化</li><li>_NSConcreteStackBlock类型的block调用copy，从栈复制到堆</li><li>_NSConcreteMallocBlock类型的block调用copy, 引用计数增加</li></ul><p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，例如：</p><ul><li>block作为函数返回值时</li><li>将block赋值给<code>__strong</code>指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul><h1 id="Auto类型变量"><a href="#Auto类型变量" class="headerlink" title="Auto类型变量"></a>Auto类型变量</h1><p>当block内部访问了对象类型的auto变量时</p><ul><li>如果block是在栈上，将不会对auto变量产生强引用</li><li>如果block被拷贝到堆上，会调用block内部的copy函数<br>copy函数内部会调用_Block_object_assign函数<br>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li><li>如果block从堆上移除，会调用block内部的dispose函数<br>dispose函数内部会调用_Block_object_dispose函数<br>_Block_object_dispose函数会自动释放引用的auto变量（release）</li></ul><h1 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h1><ul><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>__block不能修饰全局变量、静态变量（static）</li><li>编译器会将__block变量包装成一个对象</li></ul><pre class=" language-c++"><code class="language-c++">struct __Block_byref_blockPerson_0 {  void *__isa;__Block_byref_blockPerson_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); Person *__strong blockPerson;};</code></pre><h1 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="__block的内存管理"></a>__block的内存管理</h1><ul><li>当block在栈上时，并不会对__block变量产生强引用</li><li>当block被copy到堆时<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会对__block变量形成强引用（retain）</li></ul></li><li>当block从堆中移除时<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul></li></ul><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><pre class=" language-objective-c"><code class="language-objective-c">__weak typeof(self) weakSelf = self;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;block的本质&quot;&gt;&lt;a href=&quot;#block的本质&quot; class=&quot;headerlink&quot; title=&quot;block的本质&quot;&gt;&lt;/a&gt;block的本质&lt;/h1&gt;&lt;p&gt;block本质上也是一个OC对象，它内部也有个isa指针。&lt;br&gt;block是封装了函数调用
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL-正方形绘制&amp;键位控制</title>
    <link href="https://shoukaiwang.github.io/posts/d1292c0e/"/>
    <id>https://shoukaiwang.github.io/posts/d1292c0e/</id>
    <published>2020-07-08T20:07:04.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天使用OpenGL的固定存储着色器渲染正方形，并能通过键盘移动。效果如下：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-eaaa224de498e8aa.gif?imageMogr2/auto-orient/strip" alt="2020-07-08 17-31-27.2020-07-08 17_32_14.gif"></p><h1 id="正方形绘制流程"><a href="#正方形绘制流程" class="headerlink" title="正方形绘制流程"></a>正方形绘制流程</h1><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-a3f9ffc65dc0792a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenGL 正方形绘制.png"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//  main.cpp</span><span class="token comment" spellcheck="true">//  OpenGLDemo</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//  Created by SK on 2020/7/3.</span><span class="token comment" spellcheck="true">//  Copyright © 2020 SK. All rights reserved.</span><span class="token comment" spellcheck="true">//</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLShaderManager.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"GLTools.h"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;GLUT/GLUT.h></span></span><span class="token comment" spellcheck="true">//定义一个，着色管理器</span>GLShaderManager shaderManager<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//简单的批次容器，是GLTools的一个简单的容器类。</span>GLBatch triangleBatch<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 边长</span>GLfloat blockSize <span class="token operator">=</span> <span class="token number">0.2f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 正方形的4个点坐标</span>GLfloat vVerts<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token operator">-</span>blockSize<span class="token punctuation">,</span> <span class="token operator">-</span>blockSize<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>        blockSize<span class="token punctuation">,</span> <span class="token operator">-</span>blockSize<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>        blockSize<span class="token punctuation">,</span> blockSize<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>        <span class="token operator">-</span>blockSize<span class="token punctuation">,</span> blockSize<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">}</span><span class="token punctuation">;</span>GLfloat xPos <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>GLfloat yPos <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">changeSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">renderScene</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT <span class="token operator">|</span> GL_STENCIL_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    GLfloat vRed<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    M3DMatrix44f mFinalTransform<span class="token punctuation">,</span> mTransfromMatrix<span class="token punctuation">,</span> mRotationMartix<span class="token punctuation">;</span>    <span class="token function">m3dTranslationMatrix44</span><span class="token punctuation">(</span>mTransfromMatrix<span class="token punctuation">,</span> xPos<span class="token punctuation">,</span> yPos<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    //每次平移时，旋转5度</span><span class="token comment" spellcheck="true">//    static float yRot = 0.0f;</span><span class="token comment" spellcheck="true">//    yRot += 5.0f;</span><span class="token comment" spellcheck="true">//    m3dRotationMatrix44(mRotationMartix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f);</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//    //将旋转和移动的矩阵结果 合并到mFinalTransform （矩阵相乘）</span><span class="token comment" spellcheck="true">//    m3dMatrixMultiply44(mFinalTransform, mTransfromMatrix, mRotationMartix);</span>    <span class="token comment" spellcheck="true">//将矩阵结果 提交给固定着色器（平面着色器）中绘制</span>    shaderManager<span class="token punctuation">.</span><span class="token function">UseStockShader</span><span class="token punctuation">(</span>GLT_SHADER_FLAT<span class="token punctuation">,</span> mTransfromMatrix<span class="token punctuation">,</span> vRed<span class="token punctuation">)</span><span class="token punctuation">;</span>    triangleBatch<span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行交换缓存区</span>    <span class="token function">glutSwapBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">specialKeys</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    GLfloat stepSize <span class="token operator">=</span> <span class="token number">0.025f</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_UP<span class="token punctuation">)</span> <span class="token punctuation">{</span>        yPos <span class="token operator">+</span><span class="token operator">=</span> stepSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_DOWN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        yPos <span class="token operator">-</span><span class="token operator">=</span> stepSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_LEFT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        xPos <span class="token operator">-</span><span class="token operator">=</span> stepSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> GLUT_KEY_RIGHT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        xPos <span class="token operator">+</span><span class="token operator">=</span> stepSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//碰撞检测</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xPos <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0f</span> <span class="token operator">+</span> blockSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        xPos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0f</span> <span class="token operator">+</span> blockSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xPos <span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1.0f</span> <span class="token operator">-</span> blockSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        xPos <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">-</span> blockSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>yPos <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0f</span> <span class="token operator">+</span> blockSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        yPos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0f</span> <span class="token operator">+</span> blockSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>yPos <span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1.0f</span> <span class="token operator">-</span> blockSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        yPos <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">-</span> blockSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">glutPostRedisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">setupRC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.98f</span><span class="token punctuation">,</span> <span class="token number">0.40f</span><span class="token punctuation">,</span> <span class="token number">0.7f</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    shaderManager<span class="token punctuation">.</span><span class="token function">InitializeStockShaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    triangleBatch<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span>GL_TRIANGLE_FAN<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    triangleBatch<span class="token punctuation">.</span><span class="token function">CopyVertexData3f</span><span class="token punctuation">(</span>vVerts<span class="token punctuation">)</span><span class="token punctuation">;</span>    triangleBatch<span class="token punctuation">.</span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    `GLTools`函数`glSetWorkingDrectory`用来设置当前工作目录。实际上在Windows中是不必要的，因为工作目录默认就是与程序可执行执行程序相同的目录。但是在Mac OS X中，这个程序将当前工作文件夹改为应用程序捆绑包中的`/Resource`文件夹。`GLUT`的优先设定自动进行了这个中设置，但是这样中方法更加安全。    */</span>    <span class="token function">gltSetWorkingDirectory</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitDisplayMode</span><span class="token punctuation">(</span>GLUT_DOUBLE <span class="token operator">|</span> GLUT_RGBA <span class="token operator">|</span> GLUT_DEPTH <span class="token operator">|</span> GLUT_STENCIL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutInitWindowSize</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutCreateWindow</span><span class="token punctuation">(</span><span class="token string">"OpenGL Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutReshapeFunc</span><span class="token punctuation">(</span>changeSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutDisplayFunc</span><span class="token punctuation">(</span>renderScene<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutSpecialFunc</span><span class="token punctuation">(</span>specialKeys<span class="token punctuation">)</span><span class="token punctuation">;</span>    GLenum err <span class="token operator">=</span> <span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> GLEW_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"glew error: %s\n"</span><span class="token punctuation">,</span> <span class="token function">glewGetErrorString</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setupRC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glutMainLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天使用OpenGL的固定存储着色器渲染正方形，并能通过键盘移动。效果如下：&lt;br&gt;&lt;img src= &quot;/img/loading.gif&quot;
      
    
    </summary>
    
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/categories/OpenGL/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>探寻OC关联对象</title>
    <link href="https://shoukaiwang.github.io/posts/1d04a2cc/"/>
    <id>https://shoukaiwang.github.io/posts/1d04a2cc/</id>
    <published>2020-07-07T23:10:42.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><p>关联对象常用的API如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">objc_setAssociatedObject</span><span class="token punctuation">(</span>id object<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> key<span class="token punctuation">,</span>                                id value<span class="token punctuation">,</span> objc_AssociationPolicy policy<span class="token punctuation">)</span>id <span class="token function">objc_getAssociatedObject</span><span class="token punctuation">(</span>id object<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> key<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">objc_removeAssociatedObjects</span><span class="token punctuation">(</span>id object<span class="token punctuation">)</span></code></pre><p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现。</p><pre class=" language-objective-c"><code class="language-objective-c">@interface Person (Extension)@property (copy, nonatomic) NSString *name;@end@implementation Person (Extension)- (void)setName:(NSString *)name {    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);}- (NSString *)name {    return objc_getAssociatedObject(self, _cmd);}</code></pre><h1 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h1><p>实现关联对象技术的核心对象有</p><ul><li><code>AssociationsManager</code><pre class=" language-c++"><code class="language-c++">class AssociationsManager {  using Storage = ExplicitInitDenseMap<DisguisedPtr<objc_object>, ObjectAssociationMap>;  static Storage _mapStorage; // AssociationsHashMap};</code></pre></li><li><code>AssociationsHashMap</code><pre class=" language-c++"><code class="language-c++">typedef DenseMap<DisguisedPtr<objc_object>, ObjectAssociationMap> AssociationsHashMap;</code></pre></li><li><code>ObjectAssociationMap</code><pre class=" language-c++"><code class="language-c++">typedef DenseMap<const void *, ObjcAssociation> ObjectAssociationMap;</code></pre></li><li><code>ObjcAssociation</code><pre class=" language-c++"><code class="language-c++">class ObjcAssociation {  uintptr_t _policy;  id _value;}</code></pre>关联对象的原理：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-578a627de0b75b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h1 id="Runtime源码分析"><a href="#Runtime源码分析" class="headerlink" title="Runtime源码分析"></a>Runtime源码分析</h1><pre class=" language-c++"><code class="language-c++">id_object_get_associative_reference(id object, const void *key){    ObjcAssociation association{};    {        AssociationsManager manager;        AssociationsHashMap &associations(manager.get());        AssociationsHashMap::iterator i = associations.find((objc_object *)object);        if (i != associations.end()) {            ObjectAssociationMap &refs = i->second;            ObjectAssociationMap::iterator j = refs.find(key);            if (j != refs.end()) {                association = j->second;                association.retainReturnedValue();            }        }    }    return association.autoreleaseReturnedValue();}void_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy){    // This code used to work when nil was passed for object and key. Some code    // probably relies on that to not crash. Check and handle it explicitly.    // rdar://problem/44094390    if (!object && !value) return;    if (object->getIsa()->forbidsAssociatedObjects())        _objc_fatal("objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects", object, object_getClassName(object));    DisguisedPtr<objc_object> disguised{(objc_object *)object};    ObjcAssociation association{policy, value};    // retain the new value (if any) outside the lock.    association.acquireValue();    {        AssociationsManager manager;        AssociationsHashMap &associations(manager.get());        if (value) {            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap{});            if (refs_result.second) {                /* it's the first association we make */                object->setHasAssociatedObjects();            }            /* establish or replace the association */            auto &refs = refs_result.first->second;            auto result = refs.try_emplace(key, std::move(association));            if (!result.second) {                association.swap(result.first->second);            }        } else {            auto refs_it = associations.find(disguised);            if (refs_it != associations.end()) {                auto &refs = refs_it->second;                auto it = refs.find(key);                if (it != refs.end()) {                    association.swap(it->second);                    refs.erase(it);                    if (refs.size() == 0) {                        associations.erase(refs_it);                    }                }            }        }    }    // release the old value (outside of the lock).    association.releaseHeldValue();}</code></pre><h1 id="关联对象实现weak"><a href="#关联对象实现weak" class="headerlink" title="关联对象实现weak"></a>关联对象实现weak</h1><p>associated object 本身并不支持添加具备 weak 特性的 property，但我们可以通过一个小技巧来完成，下面是一个简单的实现代码</p><pre class=" language-objc"><code class="language-objc">- (void)setKey:(NSObject*)object {    id __weak weakObject = object;    id (^block)(void) = ^{ return weakObject; };    objc_setAssociatedObject(self, @selector(key), block, OBJC_ASSOCIATION_COPY);}- (NSObject*)key {    id (^block)(void) = objc_getAssociatedObject(self, _cmd);    id curContext = block ? block() : nil;    return curContext;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单应用&quot;&gt;&lt;a href=&quot;#简单应用&quot; class=&quot;headerlink&quot; title=&quot;简单应用&quot;&gt;&lt;/a&gt;简单应用&lt;/h1&gt;&lt;p&gt;关联对象常用的API如下：&lt;/p&gt;
&lt;pre class=&quot; language-c&quot;&gt;&lt;code class=&quot;langua
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>探寻Category</title>
    <link href="https://shoukaiwang.github.io/posts/b68ef59d/"/>
    <id>https://shoukaiwang.github.io/posts/b68ef59d/</id>
    <published>2020-07-07T21:09:11.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Category的底层结构"><a href="#Category的底层结构" class="headerlink" title="Category的底层结构"></a>Category的底层结构</h1><p>在源码的中，我们可以查看到Category的底层结构（<code>objc-runtime-new.h</code>）</p><pre class=" language-c++"><code class="language-c++">struct category_t {    const char *name;    classref_t cls;    struct method_list_t *instanceMethods;    struct method_list_t *classMethods;    struct protocol_list_t *protocols;    struct property_list_t *instanceProperties;    // Fields below this point are not always present on disk.    struct property_list_t *_classProperties;    method_list_t *methodsForMeta(bool isMeta) {        if (isMeta) return classMethods;        else return instanceMethods;    }    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);    protocol_list_t *protocolsForMeta(bool isMeta) {        if (isMeta) return nullptr;        else return protocols;    }};</code></pre><p>Category的底层结构是<code>struct category_t</code>，里面包含了<code>instanceMethods</code>,<code>classMethods</code>, <code>protocols</code>, <code>instanceProperties</code>,  <code>_classProperties</code>。<br>我们平时使用categroy添加对象方法、类方法、协议、属性都有相对应的数据结构存储。但是我们发现<code>category_t</code>中没有成员变量数据结构，这也是分类中是不允许添加成员变量的原因（可以通过runtime的关联对象实现）。Category中添加的属性不会自动生成成员变量，只会生成<code>get</code>、<code>set</code>方法的声明，需要我们自己去实现。</p><h1 id="Category的加载过程"><a href="#Category的加载过程" class="headerlink" title="Category的加载过程"></a>Category的加载过程</h1><p>我们都知道，runtime在启动的时候才会加载Category,下面我们通过源码来看一下Category的加载流程。<br>首先我们先看一下runtime的初始化代码</p><pre class=" language-c++"><code class="language-c++">void _objc_init(void){    static bool initialized = false;    if (initialized) return;    initialized = true;    // fixme defer initialization until an objc-using image is found?    environ_init();    tls_init();    static_init();    runtime_init();    exception_init();    cache_init();    _imp_implementationWithBlock_init();    _dyld_objc_notify_register(&map_images, load_images, unmap_image);#if __OBJC2__    didCallDyldNotifyRegister = true;#endif}</code></pre><p><code>map_images</code>-&gt;<code>map_images_nolock</code>-&gt;<code>_read_images</code>-&gt;<code>load_categories_nolock</code></p><pre class=" language-c++"><code class="language-c++">static void load_categories_nolock(header_info *hi) {    bool hasClassProperties = hi->info()->hasCategoryClassProperties();    size_t count;    auto processCatlist = [&](category_t * const *catlist) {        for (unsigned i = 0; i < count; i++) {            category_t *cat = catlist[i];            Class cls = remapClass(cat->cls);            locstamped_category_t lc{cat, hi};            if (!cls) {                // Category's target class is missing (probably weak-linked).                // Ignore the category.                if (PrintConnecting) {                    _objc_inform("CLASS: IGNORING category \?\?\?(%s) %p with "                                 "missing weak-linked target class",                                 cat->name, cat);                }                continue;            }            // Process this category.            if (cls->isStubClass()) {                // Stub classes are never realized. Stub classes                // don't know their metaclass until they're                // initialized, so we have to add categories with                // class methods or properties to the stub itself.                // methodizeClass() will find them and add them to                // the metaclass as appropriate.                if (cat->instanceMethods ||                    cat->protocols ||                    cat->instanceProperties ||                    cat->classMethods ||                    cat->protocols ||                    (hasClassProperties && cat->_classProperties))                {                    objc::unattachedCategories.addForClass(lc, cls);                }            } else {                // First, register the category with its target class.                // Then, rebuild the class's method lists (etc) if                // the class is realized.                if (cat->instanceMethods ||  cat->protocols                    ||  cat->instanceProperties)                {                    if (cls->isRealized()) {                        attachCategories(cls, &lc, 1, ATTACH_EXISTING);                    } else {                        objc::unattachedCategories.addForClass(lc, cls);                    }                }                if (cat->classMethods  ||  cat->protocols                    ||  (hasClassProperties && cat->_classProperties))                {                    if (cls->ISA()->isRealized()) {                        attachCategories(cls->ISA(), &lc, 1, ATTACH_EXISTING | ATTACH_METACLASS);                    } else {                        objc::unattachedCategories.addForClass(lc, cls->ISA());                    }                }            }        }    };    processCatlist(_getObjc2CategoryList(hi, &count));    processCatlist(_getObjc2CategoryList2(hi, &count));}</code></pre><pre class=" language-c++"><code class="language-c++">static voidattachCategories(Class cls, const locstamped_category_t *cats_list, uint32_t cats_count,                 int flags){    if (slowpath(PrintReplacedMethods)) {        printReplacements(cls, cats_list, cats_count);    }    if (slowpath(PrintConnecting)) {        _objc_inform("CLASS: attaching %d categories to%s class '%s'%s",                     cats_count, (flags & ATTACH_EXISTING) ? " existing" : "",                     cls->nameForLogging(), (flags & ATTACH_METACLASS) ? " (meta)" : "");    }    /*     * Only a few classes have more than 64 categories during launch.     * This uses a little stack, and avoids malloc.     *     * Categories must be added in the proper order, which is back     * to front. To do that with the chunking, we iterate cats_list     * from front to back, build up the local buffers backwards,     * and call attachLists on the chunks. attachLists prepends the     * lists, so the final result is in the expected order.     */    constexpr uint32_t ATTACH_BUFSIZ = 64;    method_list_t   *mlists[ATTACH_BUFSIZ];    property_list_t *proplists[ATTACH_BUFSIZ];    protocol_list_t *protolists[ATTACH_BUFSIZ];    uint32_t mcount = 0;    uint32_t propcount = 0;    uint32_t protocount = 0;    bool fromBundle = NO;    bool isMeta = (flags & ATTACH_METACLASS);    auto rwe = cls->data()->extAllocIfNeeded();    for (uint32_t i = 0; i < cats_count; i++) {        auto& entry = cats_list[i];        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);        if (mlist) {            if (mcount == ATTACH_BUFSIZ) {                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);                rwe->methods.attachLists(mlists, mcount);                mcount = 0;            }            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;            fromBundle |= entry.hi->isBundle();        }        property_list_t *proplist =            entry.cat->propertiesForMeta(isMeta, entry.hi);        if (proplist) {            if (propcount == ATTACH_BUFSIZ) {                rwe->properties.attachLists(proplists, propcount);                propcount = 0;            }            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;        }        protocol_list_t *protolist = entry.cat->protocolsForMeta(isMeta);        if (protolist) {            if (protocount == ATTACH_BUFSIZ) {                rwe->protocols.attachLists(protolists, protocount);                protocount = 0;            }            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;        }    }    if (mcount > 0) {        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);        rwe->methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);        if (flags & ATTACH_EXISTING) flushCaches(cls);    }    rwe->properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);    rwe->protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);}</code></pre><h1 id="Load方法"><a href="#Load方法" class="headerlink" title="+Load方法"></a>+Load方法</h1><ul><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li></ul><p>调用顺序：</p><ol><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的+load之前会先调用父类的+load</li></ul><ol start="2"><li>再调用分类的+load</li></ol><ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ol><blockquote><p>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</p></blockquote><h2 id="Load的加载流程"><a href="#Load的加载流程" class="headerlink" title="Load的加载流程"></a>Load的加载流程</h2><pre class=" language-c"><code class="language-c"><span class="token function">load_images</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path __unused<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> mach_header <span class="token operator">*</span>mh<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>didInitialAttachCategories <span class="token operator">&amp;&amp;</span> didCallDyldNotifyRegister<span class="token punctuation">)</span> <span class="token punctuation">{</span>        didInitialAttachCategories <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token function">loadAllCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Return without taking locks if there are no +load methods here.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasLoadMethods</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> headerType <span class="token operator">*</span><span class="token punctuation">)</span>mh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    recursive_mutex_locker_t <span class="token function">lock</span><span class="token punctuation">(</span>loadMethodLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Discover load methods</span>    <span class="token punctuation">{</span>        mutex_locker_t <span class="token function">lock2</span><span class="token punctuation">(</span>runtimeLock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">prepare_load_methods</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> headerType <span class="token operator">*</span><span class="token punctuation">)</span>mh<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Call +load methods (without runtimeLock - re-entrant)</span>    <span class="token function">call_load_methods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">call_load_methods</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> bool loading <span class="token operator">=</span> NO<span class="token punctuation">;</span>    bool more_categories<span class="token punctuation">;</span>    loadMethodLock<span class="token punctuation">.</span><span class="token function">assertLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Re-entrant calls do nothing; the outermost call will finish the job.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loading<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    loading <span class="token operator">=</span> YES<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>pool <span class="token operator">=</span> <span class="token function">objc_autoreleasePoolPush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. Repeatedly call class +loads until there aren't any more</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>loadable_classes_used <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">call_class_loads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2. Call category +loads ONCE</span>        more_categories <span class="token operator">=</span> <span class="token function">call_category_loads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. Run more +loads if there are classes OR more untried categories</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>loadable_classes_used <span class="token operator">></span> <span class="token number">0</span>  <span class="token operator">||</span>  more_categories<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">objc_autoreleasePoolPop</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>    loading <span class="token operator">=</span> NO<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">call_category_loads</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> shift<span class="token punctuation">;</span>    bool new_categories_added <span class="token operator">=</span> NO<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Detach current loadable list.</span>    <span class="token keyword">struct</span> loadable_category <span class="token operator">*</span>cats <span class="token operator">=</span> loadable_categories<span class="token punctuation">;</span>    <span class="token keyword">int</span> used <span class="token operator">=</span> loadable_categories_used<span class="token punctuation">;</span>    <span class="token keyword">int</span> allocated <span class="token operator">=</span> loadable_categories_allocated<span class="token punctuation">;</span>    loadable_categories <span class="token operator">=</span> nil<span class="token punctuation">;</span>    loadable_categories_allocated <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    loadable_categories_used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Call all +loads for the detached list.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> used<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Category cat <span class="token operator">=</span> cats<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cat<span class="token punctuation">;</span>        load_method_t load_method <span class="token operator">=</span> <span class="token punctuation">(</span>load_method_t<span class="token punctuation">)</span>cats<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>method<span class="token punctuation">;</span>        Class cls<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cat<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        cls <span class="token operator">=</span> <span class="token function">_category_getClass</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cls  <span class="token operator">&amp;&amp;</span>  cls<span class="token operator">-></span><span class="token function">isLoadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>PrintLoading<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"LOAD: +[%s(%s) load]\n"</span><span class="token punctuation">,</span>                              cls<span class="token operator">-></span><span class="token function">nameForLogging</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              <span class="token function">_category_getName</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token punctuation">(</span><span class="token operator">*</span>load_method<span class="token punctuation">)</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> @<span class="token function">selector</span><span class="token punctuation">(</span>load<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cats<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cat <span class="token operator">=</span> nil<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Compact detached list (order-preserving)</span>    shift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> used<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cats<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cat<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cats<span class="token punctuation">[</span>i<span class="token operator">-</span>shift<span class="token punctuation">]</span> <span class="token operator">=</span> cats<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            shift<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    used <span class="token operator">-</span><span class="token operator">=</span> shift<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Copy any new +load candidates from the new list to the detached list.</span>    new_categories_added <span class="token operator">=</span> <span class="token punctuation">(</span>loadable_categories_used <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loadable_categories_used<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>used <span class="token operator">==</span> allocated<span class="token punctuation">)</span> <span class="token punctuation">{</span>            allocated <span class="token operator">=</span> allocated<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">;</span>            cats <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> loadable_category <span class="token operator">*</span><span class="token punctuation">)</span>                <span class="token function">realloc</span><span class="token punctuation">(</span>cats<span class="token punctuation">,</span> allocated <span class="token operator">*</span>                                  <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> loadable_category<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cats<span class="token punctuation">[</span>used<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> loadable_categories<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Destroy the new list.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadable_categories<span class="token punctuation">)</span> <span class="token function">free</span><span class="token punctuation">(</span>loadable_categories<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Reattach the (now augmented) detached list. </span>    <span class="token comment" spellcheck="true">// But if there's nothing left to load, destroy the list.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">)</span> <span class="token punctuation">{</span>        loadable_categories <span class="token operator">=</span> cats<span class="token punctuation">;</span>        loadable_categories_used <span class="token operator">=</span> used<span class="token punctuation">;</span>        loadable_categories_allocated <span class="token operator">=</span> allocated<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cats<span class="token punctuation">)</span> <span class="token function">free</span><span class="token punctuation">(</span>cats<span class="token punctuation">)</span><span class="token punctuation">;</span>        loadable_categories <span class="token operator">=</span> nil<span class="token punctuation">;</span>        loadable_categories_used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        loadable_categories_allocated <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>PrintLoading<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadable_categories_used <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">_objc_inform</span><span class="token punctuation">(</span><span class="token string">"LOAD: %d categories still waiting for +load\n"</span><span class="token punctuation">,</span>                         loadable_categories_used<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new_categories_added<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h1><p>+initialize方法会在类第一次接收到消息时调用。<br>先调用父类的+initialize，再调用子类的+initialize，每个类只会初始化1次。</p><p>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点：</p><ul><li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li><li>如果分类实现了+initialize，就覆盖类本身的+initialize调用<h2 id="Initialize的流程"><a href="#Initialize的流程" class="headerlink" title="Initialize的流程"></a>Initialize的流程</h2><code>objc_msgSend</code>-&gt;<code>class_getInstanceMethod</code>-&gt;<code>lookUpImpOrForward</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeNonMetaClass</code><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">callInitialize</span><span class="token punctuation">(</span>Class cls<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Class<span class="token punctuation">,</span> SEL<span class="token punctuation">)</span><span class="token punctuation">)</span>objc_msgSend<span class="token punctuation">)</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> @<span class="token function">selector</span><span class="token punctuation">(</span>initialize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><pre><code># 总结Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Category的底层结构&quot;&gt;&lt;a href=&quot;#Category的底层结构&quot; class=&quot;headerlink&quot; title=&quot;Category的底层结构&quot;&gt;&lt;/a&gt;Category的底层结构&lt;/h1&gt;&lt;p&gt;在源码的中，我们可以查看到Category的底层结构
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>探寻KVO &amp; KVC</title>
    <link href="https://shoukaiwang.github.io/posts/edbcd340/"/>
    <id>https://shoukaiwang.github.io/posts/edbcd340/</id>
    <published>2020-07-07T16:12:21.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><blockquote><h3 id="KVO的本质是什么？"><a href="#KVO的本质是什么？" class="headerlink" title="KVO的本质是什么？"></a>KVO的本质是什么？</h3><p>KVO的全称是Key-Value Observing，可以用于监听某个对象属性值的改变。<br>主要使用下面几个方法：</p></blockquote><pre class=" language-objective-c"><code class="language-objective-c">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary<NSKeyValueChangeKey, id> *)change context:(nullable void *)context;- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</code></pre><p>我们自定义一个Person对象，我们通过给Person对象添加KVO监听，来观察添加KVO前后的变化，见下图：<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-19ee7654a5b769cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从打印结果我们可以看到：</p><ul><li>person1的类对象改变成了<code>NSKVONotifying_Person</code></li><li>通过输出方法的地址，我们发现添加KVO之后，实际调用的是<code>Foundation _NSSetIntValueAndNotify</code><br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-95f6ce87a552dddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><strong>下图是KVO实现的伪代码</strong><br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7277e53a2e4df56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们发现，当对象通过KVO监听属性变化时，会利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>当修改instance对象的属性时，</p><ul><li>会调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数</li><li><code>willChangeValueForKey:</code></li><li><code>父类原来的setter</code></li><li><code>didChangeValueForKey:</code>内部会触发监听器（Oberser）的监听方法( <code>observeValueForKeyPath:ofObject:change:context:</code>）</li></ul><p>如何手动触发KVO？</p><blockquote><p>手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></blockquote><p>直接修改成员变量会触发KVO么？</p><blockquote><p>不会触发KVO</p></blockquote><h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性，常见的API如下：</p><pre class=" language-objective-c"><code class="language-objective-c">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (id)valueForKey:(NSString *)key; </code></pre><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-12fbc634fad637a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-9f8740eba418b2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h1&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;KVO的本质是什么？&quot;&gt;&lt;a href=&quot;#KVO的本质是什么？&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL初探</title>
    <link href="https://shoukaiwang.github.io/posts/7c1e6eee/"/>
    <id>https://shoukaiwang.github.io/posts/7c1e6eee/</id>
    <published>2020-07-03T17:35:34.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形API简介"><a href="#图形API简介" class="headerlink" title="图形API简介"></a>图形API简介</h1><ul><li><strong>OpenGL (Open Graphics Library)</strong>是一个跨编程语言、跨平台的编程图形程序接口，它将计算机的资源抽象成为一个OpenGL的对象，对这些资源的操作抽象为⼀个个的<strong>OpenGL</strong>指令</li><li><strong>OpenGL ES (OpenGL for Embedded Systems)</strong>是 OpenGL 三维图形 API 的子集，针对手机、 PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。</li><li><strong>DirectX</strong> 是由很多API组成的，DirectX并不是一个单纯的图形API. 最重要的是DirectX是属于 Windows上一个多媒体处理框架.并不支持Windows以外的平台,所以不是跨平台框架. 按照性质分类，可以分为四⼤部分，显示部分、声音部分、输入部分和网络部分.</li><li><strong>Metal</strong>: Apple为游戏开发者推出了新的平台技术 Metal，该技术能够为 3D 图像提高 10 倍的渲染性能.Metal 是Apple为了解决3D渲染而推出的框架。</li></ul><h3 id="图形API目的是解决什么问题"><a href="#图形API目的是解决什么问题" class="headerlink" title="图形API目的是解决什么问题"></a>图形API目的是解决什么问题</h3><blockquote><p>OpenGL /OpenGL ES/ Metal 在任何项目中解决问题的本质就是利用GPU芯片来高效渲染图形图像.<br>图形API 是iOS开发者唯一接近GPU的方式. </p></blockquote><ul><li>游戏开发中,对于游戏场景/游戏人物的渲染</li><li>⾳视频开发中,对于视频解码后的数据渲染</li><li>地图引擎,对于地图上的数据渲染</li><li>动画中,实现动画的绘制</li><li>视频处理中,对于视频加上滤镜效果</li></ul><h1 id="OpenGL专业名词"><a href="#OpenGL专业名词" class="headerlink" title="OpenGL专业名词"></a>OpenGL专业名词</h1><h3 id="OpenGL上下文（Context）"><a href="#OpenGL上下文（Context）" class="headerlink" title="OpenGL上下文（Context）"></a>OpenGL上下文（Context）</h3><ul><li>在应用程序调用任何OpenGL的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是⼀个⾮常庞大的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执行的基础</li><li>OpenGL的函数不管在哪个语言中，都是类似C语言一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然你得首先把这个对象设置为当前对象。因此，通过OpenGL指令的封装，是可以将OpenGL的相关调用封装成为一个面向对象的图形API</li><li>由于OpenGL上下文是⼀个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的⽅案，会比反复切换上下文，或者⼤量修改渲染状态，更加合理高效的.</li></ul><h3 id="OpenGL状态机"><a href="#OpenGL状态机" class="headerlink" title="OpenGL状态机"></a>OpenGL状态机</h3><p>状态机是理论上的一种机器。描述了⼀个对象在其生命周期内所经历的各种状态，状态间的转变，发⽣生转变的动因，条件及转变中所执⾏行行的活动。或者说状态机是 ⼀种行为，说明对象在其生命周期中响应事件所经历的状态序列以及对那些状态事件的响应。因此具有以下特点:</p><ul><li>有记忆功能，能记住其当前的状态</li><li>可以接收输入，根据输入的内容和⾃己的原先状态，修改⾃己当前状态，并且可以有对应输出</li><li>当进入特殊状态(停机状态)的时候，变不不再接收输入，停⽌工作</li></ul><p>类推到OpenGL 中来,可以这么理解:</p><ul><li>OpenGL可以记录⾃己的状态(如当前所使用的颜色、是否开启了混合功能等)</li><li>OpenGL可以接收输入(当调用OpenGL函数的时候，实际上可以看成 OpenGL在接收我们的输入)，如我们调用glColor3f，则OpenGL接收到这个输入后会修改⾃己的“当前颜色”这个状态</li><li>OpenGL可以进入停止状态，不再接收输入。在程序退出前，OpenGL总会先停止工作的</li></ul><h3 id="渲染（Rendering）"><a href="#渲染（Rendering）" class="headerlink" title="渲染（Rendering）"></a>渲染（Rendering）</h3><p>就是将图像和图形数据转换成3D空间图像的操作。</p><h3 id="顶点数组（VertexArray）-amp-顶点缓冲区（VertexBuffer）"><a href="#顶点数组（VertexArray）-amp-顶点缓冲区（VertexBuffer）" class="headerlink" title="顶点数组（VertexArray）&amp; 顶点缓冲区（VertexBuffer）"></a>顶点数组（VertexArray）&amp; 顶点缓冲区（VertexBuffer）</h3><ul><li>画图一般是先画好图像的⻣架，然后再往骨架里面填充颜⾊，这对于 OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGL ES中，有3种类型的图元：<strong>点</strong>、<strong>线</strong>、<strong>三⻆形</strong>。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。⽽性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区</li><li>顶点指的是我们在绘制⼀个图形时,它的顶点位置数据.⽽这个数据可以直接存储在数组中或者将其缓存到GPU内存中<h3 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h3>管线可以理解为渲染流水线。在OpenGL下渲染图形的时候，显卡在处理数据时是按照一个固定的顺序，类似于流水线般，按照先后顺序一个接一个的执行。而且必须严格按照这个顺序，不能打破。<h3 id="固定管线-存储着色器"><a href="#固定管线-存储着色器" class="headerlink" title="固定管线/存储着色器"></a>固定管线/存储着色器</h3></li><li>在早期的OpenGL 版本,它封装了很多种着色器程序块内置的一段包含了光照、坐标变换、裁剪等诸多功能的固定shader程序来完成，来帮助开发者来完成图形的渲染。而开发者只需要传入相应的参数,就能快速完成图形的渲染。类似于iOS开发会封装很多API,而我们只需要调⽤,就可以实现功能。不需要关注底层实现原理</li><li>但是由于OpenGL 的使⽤用场景非常丰富，固定管线或存储着色器器⽆法完成每⼀个业务.这时将相关部分开放成可编程</li></ul><h3 id="着色器程序Shader"><a href="#着色器程序Shader" class="headerlink" title="着色器程序Shader"></a>着色器程序Shader</h3><p>着色器（Shader）是用来实现图像渲染的，用来替代固定渲染管线的可编辑程序，即是可编程渲染管线。因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编辑成的着色器程序。<br>常见的着色器主要有：顶点着色器(VertexShader)，片段着色器(FragmentShader)/像素着色器(PixelShader)<br>，几何着色器(GeometryShader)，曲面细分着色器(TessellationShader)。最重要的是顶点着色器和片段着色器。<br>OpenGL在处理shader的时候，通过编译，链接等步骤，生成着色器程序(glProgram),着色器程序同时包含了顶点着色器和片断着色器的运算逻辑。在OpenGL进行渲染的时候，首先由顶点着色器对传入的顶点数据进行计算，再通过图元装配，将顶点转换为图元，然后进行光栅化，将图元转换为栅格化数据，最后，将栅格化数据传入片段着色器中进行计算，片段着色器会对栅格化数据中的每一个像素进行计算，并决定像素的颜色。</p><h3 id="顶点着色器VertexShader"><a href="#顶点着色器VertexShader" class="headerlink" title="顶点着色器VertexShader"></a>顶点着色器VertexShader</h3><ul><li>一般⽤来处理理图形每个顶点变换(旋转/平移/投影等)</li><li>顶点着色器是OpenGL中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着⾊器运算过程中⽆法访问其他顶点的数据</li><li>一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这里发⽣的。<h3 id="片元着色器-FragmentShader"><a href="#片元着色器-FragmentShader" class="headerlink" title="片元着色器 FragmentShader"></a>片元着色器 FragmentShader</h3></li><li>一般⽤来处理图形中每个像素点颜色计算和填充</li><li>片段着色器是OpenGL中⽤于计算片段(像素)颜色的程序。片段着⾊色器是逐像素运算的程序，也就是说每个像素都会执行⼀次片段着⾊色器，当然也是并行的<h3 id="GLSL（OpenGL-Shading-language"><a href="#GLSL（OpenGL-Shading-language" class="headerlink" title="GLSL（OpenGL Shading language)"></a>GLSL（OpenGL Shading language)</h3>OpenGL着色语言（OpenGL Shading language)是用来在OpenGl中着色编程的语言，类似于C语言。他们是在图形卡的GPU（Graphic Proccessor Unit图形处理单元）上执行的。代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。比如：视图转换、投影转换等。GLSL的着色器代码分成两个部分：顶点着色器和片段着色器</li></ul><h3 id="光栅化Rasterization"><a href="#光栅化Rasterization" class="headerlink" title="光栅化Rasterization"></a>光栅化Rasterization</h3><ul><li>是把顶点数据转换成片元的过程，具有将图转化成为一个个栅格组成的图像的作用。特点是每个元素对应帧缓冲区中的一个像素。</li><li>光栅化就是把顶点数据转换为片元的过程。片元中的每一个元素对应于帧缓冲区中的一个像素</li><li>光栅化其实是一种将几何图元变为二维图像的过程。该过程包含了两部分的工作。第一部分工作：决定了窗口坐标中哪些整型格栅区域被基本图元占用。第二部分工作：分配一个颜色值和一个深度值到各个区域。光栅化过程产生的是片元。</li><li>把物体的数学描述以及与物体相关的颜色信息转换为屏幕上用于对应位置的像素及⽤于填充像素的颜色，这个过程称为光栅化，这是一个将模拟信号转化为离散信号的过程</li></ul><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纹理可以理解为一个图片，也就是位图。⼤家在渲染图形时需要在其编码填充图⽚,为了使得场景更加逼真.⽽这里使⽤的图片,就是常说的纹理.但是在OpenGL,我们更加习惯叫纹理,⽽不是图片。</p><h3 id="混合（Blending）"><a href="#混合（Blending）" class="headerlink" title="混合（Blending）"></a>混合（Blending）</h3><p>在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上的颜色进行混合，混合的算法可以通过OpenGL的函数进行指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合 算法，⼀般可以通过像素着⾊器进行实现，当然性能会比原生的混合算法差一些。</p><h3 id="变换矩阵-Transformation"><a href="#变换矩阵-Transformation" class="headerlink" title="变换矩阵(Transformation)"></a>变换矩阵(Transformation)</h3><p>在图形绘制过程中，有三种变换，分别是平移，缩放，旋转。就需要使用变换矩阵。</p><h3 id="投影矩阵（Projection）"><a href="#投影矩阵（Projection）" class="headerlink" title="投影矩阵（Projection）"></a>投影矩阵（Projection）</h3><p>⽤于将3D坐标转换为二维屏幕坐标,实际线条也将在二维坐标下进行绘制。</p><h3 id="渲染上屏-交换缓冲区-SwapBuffer"><a href="#渲染上屏-交换缓冲区-SwapBuffer" class="headerlink" title="渲染上屏/交换缓冲区(SwapBuffer)"></a>渲染上屏/交换缓冲区(SwapBuffer)</h3><p>渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。要注意的是，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像。<br>为了解决这个问题，常规的OpenGL程序至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。<br>由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步。</p><p>使⽤了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高⽔水平。为了解决这个问题，引⼊了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，⽽垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图形API简介&quot;&gt;&lt;a href=&quot;#图形API简介&quot; class=&quot;headerlink&quot; title=&quot;图形API简介&quot;&gt;&lt;/a&gt;图形API简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OpenGL (Open Graphics Library)&lt;/stro
      
    
    </summary>
    
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/categories/OpenGL/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="OpenGL" scheme="https://shoukaiwang.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>探寻OC对象的本质</title>
    <link href="https://shoukaiwang.github.io/posts/5b1f4837/"/>
    <id>https://shoukaiwang.github.io/posts/5b1f4837/</id>
    <published>2020-05-22T12:01:56.000Z</published>
    <updated>2020-07-23T09:19:48.085Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要通过三个问题，一起探寻一下OC对象实现的底层原理。</p><blockquote><h1 id="一个NSObject对象占用多少内存？"><a href="#一个NSObject对象占用多少内存？" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个NSObject对象占用多少内存？</h1></blockquote><h2 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h2><p>我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-fd87193d047fe1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>其实Objective-C的面向对象都是基于C\C++的<strong>结构体</strong>实现的。<br>我们可以通过下面的命令将Objective-C代码转换为C\C++代码来看一下具体的实现。</p><blockquote><p><code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  main.m  -o  main-arm64.cpp</code></p></blockquote><p>OC代码</p><pre class=" language-objective-c"><code class="language-objective-c">#import <Foundation/Foundation.h>int main(int argc, const char * argv[]) {    @autoreleasepool {        NSObject *object = [[NSObject alloc] init];    }    return 0;}</code></pre><p>转换的C++文件<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-199b72274a35ec1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们都知道每个OC对象都包含一个<code>isa</code>指针，在NSObject的头文件中，我们可以看到如下代码：</p><pre class=" language-c++"><code class="language-c++">@interface NSObject <NSObject> {#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wobjc-interface-ivars"    Class isa  OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop}typedef struct objc_class *Class;</code></pre><p>在转换的C++代码中，我们也可以看到类似的结构体：</p><pre class=" language-c++"><code class="language-c++">struct NSObject_IMPL {    Class isa;};struct NSArray_IMPL {    struct NSObject_IMPL NSObject_IVARS;};struct NSString_IMPL {    struct NSObject_IMPL NSObject_IVARS;};struct NSDictionary_IMPL {    struct NSObject_IMPL NSObject_IVARS;};</code></pre><p>不难猜想，<code>struct NSObject_IMPL</code>其实就是NSObject的底层实现。</p><h4 id="我们思考一下，一个OC对象在内存中是如何布局的？"><a href="#我们思考一下，一个OC对象在内存中是如何布局的？" class="headerlink" title="我们思考一下，一个OC对象在内存中是如何布局的？"></a>我们思考一下，一个OC对象在内存中是如何布局的？</h4><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-f556da873ae6283b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>NSObject其实就是结构体<code>struct NSObject_IMPL</code>，包含了一个<code>isa</code>指。在64位架构下，一个指针地址占用8个字节，是不是NSObjec对象所占用的内存就是8个字节呢？下面我们通过几种方法验证一下。</p><ol><li><p>使用runtime里的<code>class_getInstanceSize ()</code>方法，获得NSObject实例对象的成员变量所占用的大小。<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-da96cd9d0b8e1af9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>使用<code>malloc_size()</code>，获得obj指针所指向内存的大小。<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-df83debe2a7f4907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><p>为什么两次结果会截然不同呢？我们看一下<code>class_getInstanceSize</code>的具体实现。</p><pre class=" language-c++"><code class="language-c++">// May be unaligned depending on class's ivars.    uint32_t unalignedInstanceSize() const {        ASSERT(isRealized());        return data()->ro()->instanceSize;    }    // Class's ivar size rounded up to a pointer-size boundary.    uint32_t alignedInstanceSize() const {        return word_align(unalignedInstanceSize());    }#ifdef __LP64__#   define WORD_SHIFT 3UL#   define WORD_MASK 7UL#   define WORD_BITS 64#else#   define WORD_SHIFT 2UL#   define WORD_MASK 3UL#   define WORD_BITS 32#endifstatic inline uint32_t word_align(uint32_t x) {    return (x + WORD_MASK) & ~WORD_MASK;}static inline size_t word_align(size_t x) {    return (x + WORD_MASK) & ~WORD_MASK;}static inline size_t align16(size_t x) {    return (x + size_t(15)) & ~size_t(15);}</code></pre><p>从源码里我们可以看到，系统在计算分配内存的时进行了字节对齐。<br>64位系统下<code>define WORD_MASK 7UL</code></p><blockquote><p>假设环境是64位机器， 传进来的数字是2<br>   return (2 + 7) &amp; (<del>7);<br>   return (0000 1001) &amp; (</del>0000 0111);<br>   return (0000 1001) &amp; (1111 1000) = (0000 1000)<br>   在计算机中， 位运算效率很高。</p></blockquote><h4 id="那为什么通过malloc-size-方法获取的是16个字节呢？"><a href="#那为什么通过malloc-size-方法获取的是16个字节呢？" class="headerlink" title="那为什么通过malloc_size ()方法获取的是16个字节呢？"></a>那为什么通过<code>malloc_size ()</code>方法获取的是16个字节呢？</h4><p>我们知道OC中创建一个对象需要调用<code>alloc</code>方法，下面我们通过设定一个符号断电<code>objc_alloc_init</code>看一下实际的调用堆栈。<br><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-9a6f781173650ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>通过调用堆栈信息，我们发现<code>alloc</code>方法会调用<code>_objc_rootAllocWithZone</code>方法，下面我们看一下这个方法的具体实现：</p><pre class=" language-c++"><code class="language-c++">NEVER_INLINEid_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused){    // allocWithZone under __OBJC2__ ignores the zone parameter    return _class_createInstanceFromZone(cls, 0, nil,                                         OBJECT_CONSTRUCT_CALL_BADALLOC);}/************************************************************************ class_createInstance* fixme* Locking: none** Note: this function has been carefully written so that the fastpath* takes no branch.**********************************************************************/static ALWAYS_INLINE id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,                              int construct_flags = OBJECT_CONSTRUCT_NONE,                              bool cxxConstruct = true,                              size_t *outAllocatedSize = nil){    ASSERT(cls->isRealized());    // Read class's info bits all at once for performance    bool hasCxxCtor = cxxConstruct && cls->hasCxxCtor();    bool hasCxxDtor = cls->hasCxxDtor();    bool fast = cls->canAllocNonpointer();    size_t size;    size = cls->instanceSize(extraBytes);    if (outAllocatedSize) *outAllocatedSize = size;    id obj;    if (zone) {        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);    } else {        obj = (id)calloc(1, size);    }    if (slowpath(!obj)) {        if (construct_flags & OBJECT_CONSTRUCT_CALL_BADALLOC) {            return _objc_callBadAllocHandler(cls);        }        return nil;    }    if (!zone && fast) {        obj->initInstanceIsa(cls, hasCxxDtor);    } else {        // Use raw pointer isa on the assumption that they might be        // doing something weird with the zone or RR.        obj->initIsa(cls);    }    if (fastpath(!hasCxxCtor)) {        return obj;    }    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;    return object_cxxConstructFromClass(obj, cls, construct_flags);}</code></pre><p>我们发现，系统为对象开辟内存空间实际调用的是这个<code>obj = (id)calloc(1, size);</code>，这里的<code>size</code>是需要分配的内存的大小。</p><blockquote><p><code>size = cls-&gt;instanceSize(extraBytes);</code></p></blockquote><pre class=" language-c++"><code class="language-c++">size_t instanceSize(size_t extraBytes) const {        if (fastpath(cache.hasFastInstanceSize(extraBytes))) {            return cache.fastInstanceSize(extraBytes);        }        size_t size = alignedInstanceSize() + extraBytes;        // CF requires all objects be at least 16 bytes.        if (size < 16) size = 16;        return size; }</code></pre><p>通过代码，我们不难发现，CF框架内部规定：当创建一个实例对象的时候，为其分配的空间不能小于16个字节。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>系统分配了16个字节给NSObject对象（通过malloc_size函数获得）<br>但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）</p><hr><blockquote><h1 id="对象的isa指针指向哪里？"><a href="#对象的isa指针指向哪里？" class="headerlink" title="对象的isa指针指向哪里？"></a>对象的isa指针指向哪里？</h1><h1 id="OC的类信息存放在哪里？"><a href="#OC的类信息存放在哪里？" class="headerlink" title="OC的类信息存放在哪里？"></a>OC的类信息存放在哪里？</h1></blockquote><h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p>Objective-C中的对象，简称OC对象，主要可以分为3种</p><ul><li>instance对象（实例对象）</li><li>class对象（类对象）</li><li>meta-class对象（元类对象）</li></ul><h2 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h2><p>instance对象就是通过类<code>alloc</code>出来的对象，每次调用<code>alloc</code>都会产生新的instance对象。<code>NSObject *obj = [[NSObject alloc] init];</code></p><p>instance对象在内存中存储的信息包括:</p><ul><li><code>isa</code>指针</li><li>其他成员变量</li></ul><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre class=" language-objective-c"><code class="language-objective-c">NSObject *object1 = [[NSObject alloc] init];NSObject *object2 = [[NSObject alloc] init];    Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = object_getClass(object1);Class objectClass4 = object_getClass(object2);Class objectClass5 = [NSObject class];</code></pre><p>objectClass1 ~ objectClass5都是NSObject的class对象（类对象），每个类在内存中有且只有一个class对象。</p><p>class对象在内存中存储的信息主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（@property）、类的对象方法信息（instance method）</li><li>类的协议信息（protocol）、类的成员变量信息（ivar）</li><li>……</li></ul><h2 id="meta-class"><a href="#meta-class" class="headerlink" title="meta-class"></a>meta-class</h2><pre class=" language-objc"><code class="language-objc">Class objectMetaClass = object_getClass(objectClass5);</code></pre><p>objectMetaClass是NSObject的meta-class对象（元类对象），每个类在内存中有且只有一个meta-class对象。<br>meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的类方法信息（class method）</li><li>……</li></ul><p><code>class_isMetaClass()</code>查看Class是否为meta-class</p><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7a6519ccf6378742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>instance的isa指向class</li><li>class的isa指向meta-class</li><li>meta-class的isa指向基类的meta-class</li><li>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</li><li>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</li><li>instance调用对象方法的轨迹<br>isa找到class，方法不存在，就通过superclass找父类</li><li>class调用类方法的轨迹<br>isa找meta-class，方法不存在，就通过superclass找父类</li></ul><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-086ca7c0da316287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从64bit开始，isa需要进行一次位运算，才能计算出真实地址。</p><pre><code># if __arm64__#   define ISA_MASK        0x0000000ffffffff8ULL# elif __x86_64__#   define ISA_MASK        0x00007ffffffffff8ULL</code></pre><h2 id="struct-objc-class的结构"><a href="#struct-objc-class的结构" class="headerlink" title="struct objc_class的结构"></a>struct objc_class的结构</h2><pre class=" language-c++"><code class="language-c++">struct objc_class : objc_object {    // Class ISA;    Class superclass;    cache_t cache;             // formerly cache pointer and vtable    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags    class_rw_t *data() const {        return bits.data();    }....}struct class_rw_ext_t {    const class_ro_t *ro;    method_array_t methods;    property_array_t properties;    protocol_array_t protocols;    char *demangledName;    uint32_t version;};struct class_rw_t {    // Be warned that Symbolication knows the layout of this structure.    uint32_t flags;    uint16_t witness;#if SUPPORT_INDEXED_ISA    uint16_t index;#endif    explicit_atomic<uintptr_t> ro_or_rw_ext;    Class firstSubclass;    Class nextSiblingClass;...}</code></pre><p><img src= "/img/loading.gif" data-src="img/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-f087ecea3ee01385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>对象的isa指针指向哪里？<br>instance对象的isa指向class对象<br>class对象的isa指向meta-class对象<br>meta-class对象的isa指向基类的meta-class对象</p></blockquote><blockquote><p>OC的类信息存放在哪里？<br>对象方法、属性、成员变量、协议信息，存放在class对象中<br>类方法，存放在meta-class对象中<br>成员变量的具体值，存放在instance对象</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要通过三个问题，一起探寻一下OC对象实现的底层原理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&quot;一个NSObject对象占用多少内存？&quot;&gt;&lt;a href=&quot;#一个NSObject对象占用多少内存？&quot; class=&quot;headerlink&quot; title=&quot;一个NS
      
    
    </summary>
    
    
      <category term="OC底层原理" scheme="https://shoukaiwang.github.io/categories/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Objective-C" scheme="https://shoukaiwang.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-常见的排序算法</title>
    <link href="https://shoukaiwang.github.io/posts/f6f7bedd/"/>
    <id>https://shoukaiwang.github.io/posts/f6f7bedd/</id>
    <published>2020-05-19T18:25:57.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>排序</strong>（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素的任一序列，重新排列成一个按关键字有序的序列。<br>由于待排序的记录数量不同，使得排序过程中设计的存储器不同，可将排序方法分为两大类：</p><ul><li><strong>内部排序</strong>，指的是待排序记录存放在计算机存储器中进行的排序过程；</li><li><strong>外部排序</strong>，指的是待排序记录的数据量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序(Bubble Sort) 一种交换排序,它的基本思想就是: 两两⽐相邻的记录的关键字,如果 反序则交换,直到没有反序的记录为止。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 冒泡排序-对顺序表L进行交换排序</span><span class="token keyword">void</span> <span class="token function">BubbleSort0</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 冒泡排序-对顺序表L作冒泡排序</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 冒泡排序-对顺序表L冒泡排序进行优化</span><span class="token keyword">void</span> <span class="token function">BubbleSort2</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Status flag <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flag <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="简单选择排序算法-Simple-Selection-Sort"><a href="#简单选择排序算法-Simple-Selection-Sort" class="headerlink" title="简单选择排序算法(Simple Selection Sort)"></a>简单选择排序算法(Simple Selection Sort)</h2><p>简单选择排序算法 就是通过<code>n - i</code>次关键词比较,从<code>n - i + 1</code>个记录中找出关键字最小的记录,并和第<code>i</code>(1 &lt;= i &lt;= n) 个记录进行交换。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 选择排序--对顺序表L进行简单选择排序</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> min<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        min <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">></span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><strong>直接插入排序</strong>（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作使将一个记录插入已排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 直接插入排序算法--对顺序表L进行直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            L<span class="token operator">-></span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>希尔排序又称“最小增量排序”，它也是一种属插入排序类的方法，但在实际效率上较前述集中排序方法有较大的改进。<br>希尔排序的一个特点是：子序列的构成不是简单地“逐段分割”，而是将像个某个“增量”的记录组成一个子序列。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 希尔排序-对顺序表L希尔排序</span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">int</span> increment <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        increment <span class="token operator">=</span> increment <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> increment <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token operator">-></span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>i <span class="token operator">-</span> increment<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                L<span class="token operator">-></span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> increment<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> increment<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> increment<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> increment<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>increment <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><strong>堆排序</strong> 就是利用堆进行排序的算法。它的基本思想：</p><ol><li>将待排序的序列构成⼀个⼤顶堆，此时整个序列的最大值就堆顶的根结点，将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值);</li><li>然后将剩余的<code>n - 1</code>个序列重新构成一个堆，这样就会得到<code>n</code>个元素的次大值, 如此重复执行，就能得到一个有序列了；</li></ol><p>每个结点的值都⼤于或等于其左右孩⼦子结点的值, 称为<strong>大顶堆</strong>。<br>每个结点的值都小于或等于其左右孩⼦子结点的值, 称为<strong>小顶堆</strong>。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 大顶堆调整函数; 条件: 在L.r[s...m] 记录中除了下标s对应的关键字L.r[s]不符合大顶堆定义,其他均满足; 结果: 调整L.r[s]的关键字,使得L->r[s...m]这个范围内符合大顶堆定义. */</span><span class="token keyword">void</span> <span class="token function">HeapAjust</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    temp <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> s<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">>=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        L<span class="token operator">-></span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-></span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        s <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    L<span class="token operator">-></span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> L<span class="token operator">-></span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">HeapAjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">,</span> L<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> L<span class="token operator">-></span>length<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">HeapAjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素的任一序列，重新排列成一个按关键字有序的序列。&lt;br&gt;由于待排序的记录数量不同，使得排序过程中设计的存储器不同，可将排序方法分为两大类：&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-散列表查找</title>
    <link href="https://shoukaiwang.github.io/posts/5734cf9a/"/>
    <id>https://shoukaiwang.github.io/posts/5734cf9a/</id>
    <published>2020-05-18T18:14:39.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h1><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p><p>散列技术是记录的存储位置和它的关键字之间建立一个确定的对应关系t，使得每个关键字key对应一个存储位置f(key)。当查找时根据这个对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。</p><h1 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h1><p>构造哈希函数的方法有很多，首先需要明确什么是“好”的哈希函数？<br>若相对于关键字集合中的人一个键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称为此类哈希函数为<strong>均匀</strong>的哈希函数。换句话说，就是使关键字经过哈希函数得到一个随机的地址，一遍使一组关键字的哈希地址均匀分布在整个地址取件中，从而减小冲突。</p><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>取关键字或关键字的某个线性函数值为散列地址。即<br>H(key)=key或H(key) = a·key + b，<br>其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p><h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址</p><h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加</p><h3 id="保留余数法"><a href="#保留余数法" class="headerlink" title="保留余数法"></a>保留余数法</h3><p>选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。</p><h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key)，其中random为随机函数，通常，当关键字不等时采用此法构造哈希函数较恰当。</p><p>实际工作中虚视不同的情况采用不同的哈希函数，通常考虑因素有：</p><ol><li>计算哈希函数所需时间；</li><li>关键字的长度；</li><li>哈希表的打消；</li><li>关键字的分布情况；</li><li>记录的查找频率；</li></ol><h1 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h1><h3 id="开发寻址法"><a href="#开发寻址法" class="headerlink" title="开发寻址法"></a>开发寻址法</h3><p>Hi=(H(key) + di) MOD m,i=1,2，…，k(k&lt;=m-1）<br>其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：</p><ul><li>di=1,2,3，…，m-1，称线性探测再散列；</li><li>di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次探测再散列；</li><li>di=伪随机数序列，称伪随机探测再散列。<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3>Hi=RHi(key),i=1,2，…，k<br>RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3>将所有关键字为同义词的记录存储在同一线性表中。<h3 id="建立一个公共溢出区"><a href="#建立一个公共溢出区" class="headerlink" title="建立一个公共溢出区"></a>建立一个公共溢出区</h3>假设哈希函数的值域为[0, m - 1]，则设向量HashTable[0..m - 1]为基本表，每个分量存放一个记录，另设向量OverTable[o..v]为溢出表，所有关键字和基本表中关键字为同义词的记录，不管他们有哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是哈希表&quot;&gt;&lt;a href=&quot;#什么是哈希表&quot; class=&quot;headerlink&quot; title=&quot;什么是哈希表&quot;&gt;&lt;/a&gt;什么是哈希表&lt;/h1&gt;&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也
      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-线索二叉树</title>
    <link href="https://shoukaiwang.github.io/posts/4035dbb/"/>
    <id>https://shoukaiwang.github.io/posts/4035dbb/</id>
    <published>2020-05-18T15:18:44.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列、后序序列、这实质上是对一个非线性结构进行线性化的操作，使每个结点在这些线性序列中有且仅有一个直接前驱和直接后继。<br>但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接找到结点在任一序列中的前驱和后继的信息。<br>如何保存这种在遍历过程中得到的信息呢？对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为<strong>线索</strong>，加上线索的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程称为<strong>线索化</strong>。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li>结点左子树为空，利用左孩子的指针指向前驱结点；</li><li>结点右子树为空，利用右孩子的指针指向后继结点；</li><li>所有的前驱、后继按照某一个遍历逻辑；</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> OK 1</span><span class="token macro property">#<span class="token directive keyword">define</span> ERROR 0</span><span class="token macro property">#<span class="token directive keyword">define</span> TRUE 1</span><span class="token macro property">#<span class="token directive keyword">define</span> FALSE 0</span><span class="token macro property">#<span class="token directive keyword">define</span> MAX_TREE_SIZE 100 </span><span class="token comment" spellcheck="true">/* 二叉树的最大结点数 */</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> TElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> TElemType SqBiTree<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>TElemType Nil <span class="token operator">=</span> <span class="token string">'#'</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">pragma</span> mark--二叉树构造</span><span class="token keyword">int</span> indexs <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> String<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>String str<span class="token punctuation">;</span>Status <span class="token function">StrAssign</span><span class="token punctuation">(</span>String T<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>chars<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">*</span> <span class="token punctuation">(</span>chars <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">pragma</span> mark - Thread BiTree</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>    Link<span class="token punctuation">,</span>    Thread<span class="token punctuation">}</span> PointerTag<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BiThrNode <span class="token punctuation">{</span>    TElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BiThrNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    PointerTag LTag<span class="token punctuation">,</span> RTag<span class="token punctuation">;</span><span class="token punctuation">}</span> BiThrNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span>Status <span class="token function">visit</span><span class="token punctuation">(</span>TElemType e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span>Status <span class="token function">CreateBiThrTree</span><span class="token punctuation">(</span>BiThrTree <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    TElemType e <span class="token operator">=</span> str<span class="token punctuation">[</span>indexs<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> Nil<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token punctuation">(</span>BiThrTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiThrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">CreateBiThrTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>LTag <span class="token operator">=</span> Link<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">CreateBiThrTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">-></span>RTag <span class="token operator">=</span> Link<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span>BiThrTree pre<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiThrTree p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p<span class="token operator">-></span>LTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>            p<span class="token operator">-></span>lchild <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            p<span class="token operator">-></span>LTag <span class="token operator">=</span> Link<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre<span class="token operator">-></span>rchild<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre<span class="token operator">-></span>RTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>            pre<span class="token operator">-></span>rchild <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            pre<span class="token operator">-></span>RTag <span class="token operator">=</span> Link<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Status <span class="token function">InOrderThreading</span><span class="token punctuation">(</span>BiThrTree <span class="token operator">*</span>Thrt <span class="token punctuation">,</span> BiThrTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>Thrt <span class="token operator">=</span> <span class="token punctuation">(</span>BiThrTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiThrNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>Thrt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token operator">-></span>LTag <span class="token operator">=</span> Link<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token operator">-></span>RTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token operator">-></span>lchild <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>Thrt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token operator">-></span>lchild <span class="token operator">=</span> T<span class="token punctuation">;</span>        pre <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">InThreading</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>        pre<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token operator">*</span>Thrt<span class="token punctuation">;</span>        pre<span class="token operator">-></span>RTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token operator">*</span>Thrt<span class="token punctuation">)</span><span class="token operator">-></span>rchild <span class="token operator">=</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span>Status <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>BiThrTree T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    BiThrTree p<span class="token punctuation">;</span>    p <span class="token operator">=</span> T<span class="token operator">-></span>lchild<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>LTag <span class="token operator">==</span> Link<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>RTag <span class="token operator">==</span> Thread <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">!=</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>            <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列、后序序列、这实质上是对一个非线性结构进行线性化
      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-查找</title>
    <link href="https://shoukaiwang.github.io/posts/24abe8e7/"/>
    <id>https://shoukaiwang.github.io/posts/24abe8e7/</id>
    <published>2020-05-15T15:12:06.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>查找表</strong>是由同一类型的数据元素构成的集合。由于集合中的数据元素之间存在着完全松散的换洗，因此查找表是一种非常领边的数据结构。</p><p>对查找表经常进行的操作：</p><ul><li>查询某个特定的数据元素是否在查找表中；</li><li>检索某个特定的数据元素的各种属性；</li><li>在查找表中插入一个数据元素；</li><li>在查找表中删去某个数据元素；</li></ul><h1 id="静态查找表（Static-search-table）"><a href="#静态查找表（Static-search-table）" class="headerlink" title="静态查找表（Static search table）"></a>静态查找表（Static search table）</h1><h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><p><strong>顺序查找</strong>（Sequential Search）的查找过程：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若知道第一个记录，其关键字和给定值比较不相等，则表明表中没有所查记录，查找不成功。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 顺序查找</span><span class="token keyword">int</span> <span class="token function">Sequential_Search</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> I <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Sequential_Search_Guard</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><p><strong>折半查找</strong>（Binary Search）的查找过程：先确定待查找记录所在的范围，然后珠逐步缩小范围直到找到或找不到该记录为止。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 折半查找算法</span><span class="token keyword">int</span> <span class="token function">Binary_Search</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 插值查找</span><span class="token keyword">int</span> <span class="token function">Interpolation_Search</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>key <span class="token operator">-</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//5.斐波拉契查找</span><span class="token keyword">int</span> F<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 斐波那契数列 */</span><span class="token keyword">int</span> <span class="token function">Fibonacci_Search</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    high <span class="token operator">=</span> n<span class="token punctuation">;</span>    k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> F<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> F<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> F<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">></span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> n<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="动态查找表-（Dynamic-search-table）"><a href="#动态查找表-（Dynamic-search-table）" class="headerlink" title="动态查找表 （Dynamic search table）"></a>动态查找表 （Dynamic search table）</h1><p><strong>二叉排序树</strong>（Binary sort Tree）或者是一颗空树；或者是具有下列性质的二叉树；</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的跟结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的跟结点的值；</li><li>它的左、右子树也分别为二叉树排序树；<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span></code></pre></li></ol><p>typedef  struct BiTNode {<br>    int data;<br>    struct BiTNode *lchild, *rchild;<br>} BiTNode, *BiTree;</p><p>// 二叉排序树–查找<br>Status SearchBST(BiTree T, int key, BiTree f, BiTree *p) {<br>    if (!T) {<br>        *p = f;<br>        return FALSE;<br>    }</p><pre><code>if (T-&gt;data == key) {    *p = T;    return TRUE;} else if (key &lt; T-&gt;data) {    return SearchBST(T-&gt;lchild, key, T, p);} else {    return SearchBST(T-&gt;rchild, key, T, p);}</code></pre><p>}</p><p>Status InsertBST(BiTree <em>T, int key) {<br>    BiTree p, s;<br>    if (!SearchBST(</em>T, key, NULL, &amp;p)) {<br>        s = (BiTree)malloc(sizeof(BiTNode));<br>        s-&gt;data = key;<br>        s-&gt;lchild = s-&gt;rchild = NULL;</p><pre><code>    if (!p) {        *T = s;    } else if (key &lt; p-&gt;data) {        p-&gt;lchild = s;    } else {        p-&gt;rchild = s;    }    return TRUE;}return FALSE;</code></pre><p>}</p><p>// 从二叉排序树中删除结点p,并重接它的左或者右子树;<br>Status Delete(BiTree <em>p){<br>    BiTree temp, s;<br>    if((</em>p)-&gt;rchild == NULL) {<br>        temp = <em>p;<br>        *p = (</em>p)-&gt;lchild;<br>        free(temp);<br>    } else if((<em>p)-&gt;lchild == NULL) {<br>        temp = *p;<br>        *p = (</em>p)-&gt;rchild;<br>        free(temp);<br>    } else {<br>        temp = <em>p;<br>        s = (</em>p)-&gt;lchild;<br>        while (s-&gt;rchild) {<br>            temp = s;<br>            s = s-&gt;rchild;<br>        }<br>        (*p)-&gt;data = s-&gt;data;</p><pre><code>    if(temp != *p)        temp-&gt;rchild = s-&gt;lchild;    else        temp-&gt;lchild = s-&gt;lchild;    free(s);}return  TRUE;</code></pre><p>}</p><p>// 查找结点,并将其在二叉排序中删除;<br>Status DeleteBST(BiTree <em>T, int key) {<br>    if(!</em>T) {<br>        return FALSE;<br>    } else {<br>        if (key == (<em>T)-&gt;data)<br>            return Delete(T);<br>        else if (key &lt; (</em>T)-&gt;data)<br>            return DeleteBST(&amp;(<em>T)-&gt;lchild, key);<br>        else<br>            return DeleteBST(&amp;(</em>T)-&gt;rchild, key);<br>    }<br>}</p><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;查找表&lt;/strong&gt;是由同一类型的数据元素构成的集合。由于集合中的数据元素之间存在着完全松散的换洗，因此查找表是一种非常领边的数据结构。&lt;/p&gt;
&lt;p&gt;对查找表经常进行的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询某个特定的数据元素是否在查找表中；&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-拓扑排序 &amp; 关键路径</title>
    <link href="https://shoukaiwang.github.io/posts/b47980b9/"/>
    <id>https://shoukaiwang.github.io/posts/b47980b9/</id>
    <published>2020-05-13T17:55:43.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序的序列，简称<strong>拓扑序列</strong>。简单的说，由某个集合上的一个偏序得到集合上的一个全序，这个操作称之为<strong>拓扑排序</strong>。<br>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样有向图为顶点表示活动的网，我们称为<strong>AOV网</strong>。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>从AOV网中选择⼀个入度为0的顶点输出</li><li>然后删去此顶点,并删除以此顶点为尾的弧. </li><li>继续重复此步骤,直到输出全部顶点或AOV网中不存在入度为0的顶点为⽌.</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> MGraph <span class="token punctuation">{</span>    <span class="token keyword">int</span> vexs<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arc<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numVertexes<span class="token punctuation">,</span> numEdges<span class="token punctuation">;</span><span class="token punctuation">}</span> MGraph<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> EdgeNode <span class="token punctuation">{</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//邻接点域，存储该顶点对应的下标</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>    <span class="token keyword">struct</span> EdgeNode <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>EdgeNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> VertexNode <span class="token punctuation">{</span>    <span class="token keyword">int</span> in<span class="token punctuation">;</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    EdgeNode <span class="token operator">*</span>firstedge<span class="token punctuation">;</span><span class="token punctuation">}</span> VertexNode<span class="token punctuation">,</span> AdjList<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    AdjList adjList<span class="token punctuation">;</span>    <span class="token keyword">int</span> numVertexes<span class="token punctuation">,</span> numEdges<span class="token punctuation">;</span><span class="token punctuation">}</span> graphAdjList<span class="token punctuation">,</span> <span class="token operator">*</span>GraphAdjList<span class="token punctuation">;</span>Status <span class="token function">TopologicalSort</span><span class="token punctuation">(</span>GraphAdjList GL<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    EdgeNode <span class="token operator">*</span>e<span class="token punctuation">;</span>    <span class="token keyword">int</span> getTop<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        getTop <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d -> "</span><span class="token punctuation">,</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            k <span class="token operator">=</span> e<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表表示活动的网,我们称之为<strong>AOE 网</strong>(Activity On Edge Network)<br>没有入边的顶点称为始点或源点；<br>没有出边的顶点称为终点或汇点；<br>由于一个⼯程，总有一个开始，一个结束。所以正常情况下，AOE⽹网只有一个源点和一个汇点。</p><ul><li>路径上各个活动所持续的时间之和称为路径长度</li><li>从源点到汇点具有最大的路径叫关键路径</li><li>在关键路径上的活动叫关键活动</li></ul><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><ul><li>事件最早发生的时间<strong>etv</strong>(earliest time of vertex): 即顶点Vk的最早发生时间；</li><li>事件最晚发生时间<strong>ltv</strong>(latest time fo vertex):即顶点Vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期；</li><li>活动的最早开工时间<strong>ete</strong>(earliest time of edge): 即弧Ak的最早发生时间；</li><li>活动的最晚开工时间<strong>lte</strong>(latest time of edge): 即弧Ak的最晚发生时间，也就是不推迟工期的最晚开工时间；</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>etv<span class="token punctuation">,</span> <span class="token operator">*</span>ltv<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 事件最早发生时间和最迟发生时间数组，全局变量</span><span class="token keyword">int</span> <span class="token operator">*</span>stack2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用于存储拓扑序列的栈</span><span class="token keyword">int</span> top2<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 用于stack2的指针</span>Status <span class="token function">TopologicalSort</span><span class="token punctuation">(</span>GraphAdjList GL<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    top2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    stack2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span><span class="token punctuation">;</span>    etv <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        etv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    EdgeNode <span class="token operator">*</span>e<span class="token punctuation">;</span>    <span class="token keyword">int</span> getTop<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        getTop <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d -> "</span><span class="token punctuation">,</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        stack2<span class="token punctuation">[</span><span class="token operator">++</span>top2<span class="token punctuation">]</span> <span class="token operator">=</span> getTop<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            k <span class="token operator">=</span> e<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>etv<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token operator">-></span>weight <span class="token operator">></span> etv<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                etv<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> etv<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token operator">-></span>weight<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">CriticalPath</span><span class="token punctuation">(</span>GraphAdjList GL<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> k<span class="token punctuation">,</span> getTop<span class="token punctuation">;</span>    EdgeNode <span class="token operator">*</span>e<span class="token punctuation">;</span>    <span class="token function">TopologicalSort</span><span class="token punctuation">(</span>GL<span class="token punctuation">)</span><span class="token punctuation">;</span>    ltv <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ltv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> etv<span class="token punctuation">[</span>GL<span class="token operator">-></span>numVertexes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>top2 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        getTop <span class="token operator">=</span> stack2<span class="token punctuation">[</span>top2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            k <span class="token operator">=</span> e<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ltv<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> e<span class="token operator">-></span>weight <span class="token operator">&lt;</span> ltv<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ltv<span class="token punctuation">[</span>getTop<span class="token punctuation">]</span> <span class="token operator">=</span> ltv<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> e<span class="token operator">-></span>weight<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ete<span class="token punctuation">,</span>lte<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> GL<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            k <span class="token operator">=</span> e<span class="token operator">-></span>adjvex<span class="token punctuation">;</span>            ete <span class="token operator">=</span> etv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            lte <span class="token operator">=</span> ltv<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> e<span class="token operator">-></span>weight<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ete <span class="token operator">==</span> lte<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&lt;%d-%d> length:%d\n"</span><span class="token punctuation">,</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> GL<span class="token operator">-></span>adjList<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> e<span class="token operator">-></span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拓扑排序&quot;&gt;&lt;a href=&quot;#拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序&quot;&gt;&lt;/a&gt;拓扑排序&lt;/h1&gt;&lt;p&gt;对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&amp;lt;u,v&amp;gt;∈E
      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>单链表中删除相等的多余结点</title>
    <link href="https://shoukaiwang.github.io/posts/195c875e/"/>
    <id>https://shoukaiwang.github.io/posts/195c875e/</id>
    <published>2020-05-09T15:03:24.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<p>最短路径问题是<strong>图</strong>研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：</p><ul><li><p>确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。</p></li><li><p>确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</p></li><li><p>确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。</p></li><li><p>全局最短路径问题 - 求图中所有的最短路径。</p></li></ul><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>Dijkstra提出了一个按路径长度递增的次序产生最短路径的算法。<br>首先，我们引入一个辅助向量D，它的每个分量D[i]表示当前找到的从起始节点v到终点节点vi的最短路径的长度。它的初始态为：若从节点v到节点vi有弧，则D[i]为弧上的权值，否则D[i]为∞，显然，长度为<br><strong>D[j] = Min{D[i] | vi ∈V}</strong><br>的路径就是从v出发最短的一条路径，路径为(v, vi)。<br>那么，下一条长度次短的最短路径是哪一条呢？假设次短路径的终点是vk，则可想而知，这条路径或者是(v, vk)或者是(v, vj, vk)。它的长度或者是从v到vk的弧上的权值，或者是D[j]和从vj到vk的权值之和。</p><p>一般情况下，假设S为已知求得的最短路径的终点集合，则可证明：一下条最短路径（设其终点为x）或者是弧(v, x)或者是中间只经过S中的顶点而最后到达顶点x的路径。这可用反证法来证明，假设此路径上有一个顶点不在S中，则说明存在一条终点不在S中而长度比此路径短的路径。但是这是不可能的。因为，我们是按路径常度的递增次序来产生个最短路径的，故长度比此路径端的所有路径均已产生，他们的终点必定在S集合中，即假设不成立。</p><p>因此下一条次短的最短路径的长度是：<br><strong>D[j] = Min{D[i] | vi ∈ V - S}</strong><br>其中，D[i]或者是弧(v, vi)的权值，或者是D[k](vk ∈ S)和弧(vk, vi)上权值之和。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/// 最短路径 - Dijkstra 算法</span><span class="token comment" spellcheck="true">/// @param G 网图</span><span class="token comment" spellcheck="true">/// @param v0 开始的顶点</span><span class="token comment" spellcheck="true">/// @param P 前驱顶点下标</span><span class="token comment" spellcheck="true">/// @param D 表示从V0到V的最短路径长度和</span><span class="token keyword">void</span> <span class="token function">ShortestPath_Dijkstra</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">,</span> Patharc <span class="token operator">*</span>P<span class="token punctuation">,</span> ShortPathTable <span class="token operator">*</span>D<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">,</span> k<span class="token punctuation">,</span> min<span class="token punctuation">;</span>    k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> final<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        final<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    final<span class="token punctuation">[</span>v0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        min <span class="token operator">=</span> INFINITYC<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>final<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                k <span class="token operator">=</span> w<span class="token punctuation">;</span>                min <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        final<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>final<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">+</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> min <span class="token operator">+</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShortestPath_Floyd</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> Patharc <span class="token operator">*</span>P<span class="token punctuation">,</span> ShortPathTable <span class="token operator">*</span>D<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> v<span class="token punctuation">,</span> w<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>D<span class="token punctuation">)</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最短路径问题是&lt;strong&gt;图&lt;/strong&gt;研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-最小生成树</title>
    <link href="https://shoukaiwang.github.io/posts/d4f49403/"/>
    <id>https://shoukaiwang.github.io/posts/d4f49403/</id>
    <published>2020-05-08T17:22:11.000Z</published>
    <updated>2020-07-23T09:19:48.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>连通图的生成树</strong>是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一颗树的n-1条边。</p><p>构造连通网的最小代价生成树简称为<strong>最小生成树</strong>。</p><h1 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>定义2个数组，adjvex 用来保存相关顶点下标，lowcost 保存顶点之间的权值</li><li>初始化2个数组, 从v0开始寻找最小⽣成树, 默认v0是最小生成树上第一个顶点 </li><li>循环lowcost 数组,根据权值,找到顶点 k;</li><li>更新lowcost 数组</li><li>循环所有顶点,找到与顶点k 有关系的顶点. 并更新lowcost 数组与adjvex 数组;</li></ol><blockquote><p>注意更新lowcost 数组与adjvex 数组的条件:</p><ol><li>与顶点k 之间有连接</li><li>当前结点 j 没有加入过最小生成树;</li><li>顶点 k 与 当前顶点 j 之间的权值 小于 顶点j 与其他顶点 k 之前的权值. 则更新. 简单说就是要比较之前存储的值要小,则更新;</li></ol></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Prim算法生成最小生成树 */</span><span class="token keyword">void</span> <span class="token function">MiniSpanTree_Prim</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> min<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> adjvex<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> lowcost<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>    lowcost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    adjvex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lowcost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        adjvex<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        min <span class="token operator">=</span> INFINITYC<span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(V%d, V%d) = %d\n"</span><span class="token punctuation">,</span> adjvex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token punctuation">,</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>adjvex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">+</span><span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>adjvex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        lowcost<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                lowcost<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                adjvex<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum = %d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>将邻接矩阵转化成边表数组；</li><li>对边表数组根据权值按照从小到大的顺序排序；</li><li>遍历所有的边， 通过parent 数组找到边的连接信息，避免闭环问题；</li><li>如果不存在闭环问题,则加入到最小生成树中，并且修改parent 数组；<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Edge <span class="token punctuation">{</span> <span class="token keyword">int</span> begin<span class="token punctuation">;</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span> <span class="token keyword">int</span> weight<span class="token punctuation">;</span><span class="token punctuation">}</span> Edge<span class="token punctuation">;</span></code></pre></li></ol><p>/*<br> Prim算法生成最小生成树<br> */</p><p>void Swapn(Edge *edges, int i, int j) {<br>    int temp;<br>    temp = edges[i].begin;<br>    edges[i].begin = edges[j].begin;<br>    edges[j].begin = temp;</p><pre><code>temp = edges[i].end;edges[i].end = edges[j].end;edges[j].end = temp;temp = edges[i].weight;edges[i].weight = edges[j].weight;edges[j].weight = temp;</code></pre><p>}</p><p>void Sort(Edge edges[], MGraph *G) {<br>    int i, j;<br>    for (i = 0; i &lt; G-&gt;numEdges; i++) {<br>        for (j = i + 1; j &lt; G-&gt;numEdges; j++) {<br>            if (edges[i].weight &gt; edges[j].weight) {<br>                Swapn(edges, i, j);<br>            }<br>        }<br>    }<br>}</p><p>int Find(int *parent, int f) {<br>    while (parent[f] &gt; 0) {<br>        f = parent[f];<br>    }<br>    return f;<br>}</p><p>void MiniSpanTree_Kruskal(MGraph G)  {<br>    int i, j, n, m;<br>    int sum = 0;<br>    int k = 0;</p><pre><code>Edge edges[MAXVEX];for (i = 0; i &lt; G.numVertexes; i++) {    for (j = i + 1; j &lt; G.numVertexes; j++) {        if (G.arc[i][j] &lt; INFINITYC) {            edges[k].begin = i;            edges[k].end = j;            edges[k].weight = G.arc[i][j];            k++;        }    }}Sort(edges, &amp;G);int parent[MAXVEX] = {0};for (i = 0; i &lt; G.numEdges; i++) {    m = Find(parent, edges[i].begin);    n = Find(parent, edges[i].end);    if (m != n) {        parent[m] = n;        sum += edges[i].weight;        printf("(%d, %d) %d\n", edges[i].begin, edges[i].end, edges[i].weight);    }}printf("sum = %d\n", sum);</code></pre><p>}</p><pre><code></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;连通图的生成树&lt;/strong&gt;是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一颗树的n-1条边。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="DataStructures &amp; Algorithms" scheme="https://shoukaiwang.github.io/categories/DataStructures-Algorithms/"/>
    
    
      <category term="C" scheme="https://shoukaiwang.github.io/tags/C/"/>
    
      <category term="Algorithms" scheme="https://shoukaiwang.github.io/tags/Algorithms/"/>
    
  </entry>
  
</feed>
