<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107/"/>
      <url>/posts/16107/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL的渲染技巧-正背面剔除</title>
      <link href="/posts/ecffcb82/"/>
      <url>/posts/ecffcb82/</url>
      
        <content type="html"><![CDATA[<p>今天通过一个小案例，来讲解OpenGL的正背面剔除以及深度测试的应用。</p><h1 id="圆环的绘制"><a href="#圆环的绘制" class="headerlink" title="圆环的绘制"></a>圆环的绘制</h1><p>我们使用<code>GLTools</code>中的<code>void gltMakeTorus(GLTriangleBatch&amp; torusBatch, GLfloat majorRadius, GLfloat minorRadius, GLint numMajor, GLint numMinor)</code>方法，简单实现一下圆环的绘制。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  OpenGLDemo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by SK on 2020/7/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 SK. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLShaderManager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLTools.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLUT/GLUT.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLMatrixStack.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLFrame.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLFrustum.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLGeometryTransform.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个，着色管理器</span></span><br><span class="line">GLShaderManager shaderManager;</span><br><span class="line">GLFrame viewFrame;</span><br><span class="line">GLFrustum viewFrustum;</span><br><span class="line">GLTriangleBatch torusBatch;</span><br><span class="line">GLMatrixStack modelViewMatix;</span><br><span class="line">GLMatrixStack projectionMatrix;</span><br><span class="line">GLGeometryTransform transformPipeline;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeSize</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">    viewFrustum.SetPerspective(<span class="number">35.0f</span>, <span class="keyword">float</span>(w) / <span class="keyword">float</span>(h), <span class="number">1.0f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    projectionMatrix.LoadMatrix(viewFrustum.GetProjectionMatrix());</span><br><span class="line">    transformPipeline.SetMatrixStacks(modelViewMatix, projectionMatrix);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderScene</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br><span class="line">    GLfloat vRed[] = {<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>};</span><br><span class="line">    modelViewMatix.PushMatrix(viewFrame);</span><br><span class="line">    shaderManager.UseStockShader(GLT_SHADER_DEFAULT_LIGHT, transformPipeline.GetModelViewMatrix(), transformPipeline.GetProjectionMatrix(), vRed);</span><br><span class="line">    torusBatch.Draw();</span><br><span class="line">    modelViewMatix.PopMatrix();</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">specialKeys</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_UP)</span><br><span class="line">        viewFrame.RotateWorld(m3dDegToRad(<span class="number">-5.0</span>), <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_DOWN)</span><br><span class="line">        viewFrame.RotateWorld(m3dDegToRad(<span class="number">5.0</span>), <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_LEFT)</span><br><span class="line">        viewFrame.RotateWorld(m3dDegToRad(<span class="number">-5.0</span>), <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_RIGHT)</span><br><span class="line">        viewFrame.RotateWorld(m3dDegToRad(<span class="number">5.0</span>), <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupRC</span><span class="params">()</span> </span>{</span><br><span class="line">    glClearColor(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    shaderManager.InitializeStockShaders();</span><br><span class="line">    </span><br><span class="line">    viewFrame.MoveForward(<span class="number">7.0</span>);</span><br><span class="line">    gltMakeTorus(torusBatch, <span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">60</span>, <span class="number">30</span>);</span><br><span class="line">    glPointSize(<span class="number">4.0f</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    gltSetWorkingDirectory(argv[<span class="number">0</span>]);</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);</span><br><span class="line">    glutInitWindowSize(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">    glutCreateWindow(<span class="string">"OpenGL Demo"</span>);</span><br><span class="line">    glutReshapeFunc(changeSize);</span><br><span class="line">    glutDisplayFunc(renderScene);</span><br><span class="line">    glutSpecialFunc(specialKeys);</span><br><span class="line">    </span><br><span class="line">    GLenum err = glewInit();</span><br><span class="line">    <span class="keyword">if</span> (err != GLEW_OK) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glew error: %s\n"</span>, glewGetErrorString(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    setupRC();</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现的效果如下图所示：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-a4db983cc2572c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>看起来是一个很漂亮的圆环，当我们缓慢的转到圆环，我们会看到下面的情况：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-aaf0404b2c61b46d.gif?imageMogr2/auto-orient/strip" alt="2020-07-17 14-45-39.2020-07-17 14_51_33.gif"></p><p>No，为什么会有这些黑色的出行？为什么开始显示的好好的，一转动就出现了这样的情况？</p><p>其实在绘制3D场景的时候，我们需要决定哪些部分是对观察者可见的，哪些部分是对观察者不可见的。对于不可见的部分,应该及早丢弃。例如在一个不透明的墙壁后，就不应该渲染。这种情况叫做<code>隐藏面消除(Hidden surface elimination)</code>。</p><h1 id="消除隐藏面的解决方案"><a href="#消除隐藏面的解决方案" class="headerlink" title="消除隐藏面的解决方案"></a>消除隐藏面的解决方案</h1><h2 id="油画算法"><a href="#油画算法" class="headerlink" title="油画算法"></a>油画算法</h2><p>先绘制场景中的离观察者较远的物体，在绘制较近的物体。<br>例如下面的图例：先绘制红色部分，在绘制黄色部门，最后绘制灰色部门，即可解决隐藏面消除的问题。<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-f9c67813fca29d3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="油画算法的弊端"><a href="#油画算法的弊端" class="headerlink" title="油画算法的弊端"></a>油画算法的弊端</h4><p>如果场景里的物体出现了交叉叠加的情况，油画算法将无法处理。</p><h2 id="正背面剔除（Face-Culling）"><a href="#正背面剔除（Face-Culling）" class="headerlink" title="正背面剔除（Face Culling）"></a>正背面剔除（Face Culling）</h2><p>当我们从任意一个方向去观察一个3D图形，最多可以看到几个面？答案是最多3个面，从一个立方体的任意位置和方向上看，不可能看到多余3个面，那么我们在绘制的过程中，为何要多余的绘制那些看不到的面呢？如果我们能以某种方式去丢弃这部分数据，OpenGL在渲染的性能上可以提高50%。</p><p>OpenGL可以做到检查所有正面朝向观察者的面，并渲染它们，从而丢弃背面朝向的面。这样可以节约片元着色器的性能。</p><blockquote><p>正面和背面是有三角形的顶点定义顺序和观察者⽅向共同决定的。随着观察者的⻆度方向的改变，正面背面也会跟着改变。</p></blockquote><p>在OpenGL中开启正背面剔除的相关方法如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启表面剔除(默认背面剔除)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glEnable</span><span class="params">(GL_CULL_FACE)</span></span>;</span><br><span class="line"><span class="comment">//关闭表面剔除(默认背面剔除)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glDisable</span><span class="params">(GL_CULL_FACE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户选择剔除那个面(正面/背面)</span></span><br><span class="line"><span class="comment">//mode参数为: GL_CW,GL_CCW,默认值:GL_CCW</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glCullFace</span><span class="params">(GLenum mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mode参数为: GL_FRONT,GL_BACK,GL_FRONT_AND_BACK ,默认GL_BACK 用户指定绕序那个为正面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glFrontFace</span><span class="params">(GLenum mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//剔除正面实现例1</span></span><br><span class="line">glCullFace(GL_BACK);</span><br><span class="line">glFrontFace(GL_CW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//剔除正⾯实现例2</span></span><br><span class="line">glCullFace(GL_FRONT);</span><br></pre></td></tr></tbody></table></figure><p>我们开启正背面剔除功能，来看一下实现效果：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-6332d45bcb830341.gif?imageMogr2/auto-orient/strip" alt="2020-07-17 16-25-01.2020-07-17 16_25_33.gif"><br>开启了正背面剔除功能，我们已经基本的达到了预期的展示效果，但是当我们继续旋转时发现，出现了新的问题，如何解决这样的问题呢？这就引出了一个新的概念 <strong>深度测试</strong></p><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>那么什么是深度？<br><strong>深度</strong> 其实就是该像素点在3D世界中距离摄像机的距离，也就是<code>Z</code>值。<br><strong>深度缓存区</strong>就是一块内存区域，专门存储着每个像素点(绘制在屏幕上的)深度值。深度值(Z值)越⼤， 则离摄像机就越远。</p><p>在不使⽤深度测试的时候，如果我们先绘制⼀个距离比较近的物体，再绘制距离较远的物体,则距离远的位图因为后绘制，会把距离近的物体覆盖掉。有了深度缓冲区后，绘制物体的顺序就不那么􏰁要了。实际上，只要存在深度缓冲区，OpenGL 都会把像素的深度值写入到缓冲区中。除⾮调⽤ <code>glDepthMask(GL_FALSE)</code>来禁⽌写⼊。</p><p>未完待续…</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻autoreleasepool</title>
      <link href="/posts/2d6c78da/"/>
      <url>/posts/2d6c78da/</url>
      
        <content type="html"><![CDATA[<h1 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    @autoreleasepool {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们通过执行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fno-objc-arc  main.m</code>，将上述代码转换成C++</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> {</span></span><br><span class="line">  __AtAutoreleasePool() {</span><br><span class="line">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">  }</span><br><span class="line">  ~__AtAutoreleasePool() {</span><br><span class="line">      objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> { __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过C++代码我们发现，autoreleasepool是由objc_autoreleasePoolPush 和 objc_autoreleasePoolPop方法构成的一个结构体。</p><p>接下来我们来研究一下<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code>方法的具体实现。</p><p>参照苹果开源代码，我们找到了objc_autoreleasePoolPush和objc_autoreleasePoolPop的具体实现。（<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4</a>/）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">{</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ASSERT(obj);</span><br><span class="line">        ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">        id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">        ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line">        <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) {</span><br><span class="line">            <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (page) {</span><br><span class="line">            <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        id *dest;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(DebugPoolAllocation)) {</span><br><span class="line">            <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">            dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">        }</span><br><span class="line">        ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    popPage(<span class="keyword">void</span> *token, AutoreleasePoolPage *page, id *<span class="built_in">stop</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">        page-&gt;releaseUntil(<span class="built_in">stop</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// memory: delete empty children</span></span><br><span class="line">        <span class="keyword">if</span> (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) {</span><br><span class="line">            <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">            AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">            page-&gt;kill();</span><br><span class="line">            setHotPage(parent);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) {</span><br><span class="line">            <span class="comment">// special case: delete everything for pop(top)</span></span><br><span class="line">            <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">            page-&gt;kill();</span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) {</span><br><span class="line">            <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">            <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) {</span><br><span class="line">                page-&gt;child-&gt;kill();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) {</span><br><span class="line">                page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>通过源码我们发现自动释放池的主要底层数据结构是：<code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code><br>调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的。</p><h1 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构"></a>AutoreleasePoolPage的结构</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasePoolPageData</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</span><br><span class="line">__unsafe_unretained id *next;</span><br><span class="line"><span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</span><br><span class="line">AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">AutoreleasePoolPage *child;</span><br><span class="line"><span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;</span><br><span class="line"><span class="keyword">uint32_t</span> hiwat;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> :</span> <span class="keyword">private</span> AutoreleasePoolPageData {}</span><br></pre></td></tr></tbody></table></figure><p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址。</p><p>所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起。</p><ul><li>调用push方法会将一个<code>POOL_BOUNDARY</code>入栈，并且返回其存放的内存地址</li><li>调用pop方法时传入一个<code>POOL_BOUNDARY</code>的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个<code>POOL_BOUNDARY</code></li><li>id *next指向了下一个能存放autorelease对象地址的区域  <blockquote><p>可以通过以下私有函数来查看自动释放池的情况<br><code>extern void _objc_autoreleasePoolPrint(void);</code></p></blockquote></li></ul><h1 id="autoreleasepool与RunLoop的关系"><a href="#autoreleasepool与RunLoop的关系" class="headerlink" title="autoreleasepool与RunLoop的关系"></a>autoreleasepool与RunLoop的关系</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [NSRunLoop mainRunLoop]</span><br><span class="line">&lt;CFRunLoop 0x6000008f0300 [0x7fff8062d610]&gt;{wakeup port = 0x2207, stopped = false, ignoreWakeUps = false, </span><br><span class="line">current mode = kCFRunLoopDefaultMode,</span><br><span class="line">common modes = &lt;CFBasicHash 0x600003aacf60 [0x7fff8062d610]&gt;{type = mutable set, count = 2,</span><br><span class="line">entries =&gt;</span><br><span class="line">0 : &lt;CFString 0x7fff8692c2c0 [0x7fff8062d610]&gt;{contents = "UITrackingRunLoopMode"}</span><br><span class="line">2 : &lt;CFString 0x7fff806408e0 [0x7fff8062d610]&gt;{contents = "kCFRunLoopDefaultMode"}</span><br><span class="line">}</span><br><span class="line">,</span><br><span class="line">common mode items = &lt;CFBasicHash 0x600003aad230 [0x7fff8062d610]&gt;{type = mutable set, count = 14,</span><br><span class="line">entries =&gt;</span><br><span class="line">20 : &lt;CFRunLoopObserver 0x6000005f83c0 [0x7fff8062d610]&gt;{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff48c84b28), context = &lt;CFArray 0x600003abfd50 [0x7fff8062d610]&gt;{type = mutable-small, count = 1, values = (</span><br><span class="line">0 : &lt;0x7f9ec100f038&gt;</span><br><span class="line">)}}</span><br><span class="line"></span><br><span class="line">22 : &lt;CFRunLoopObserver 0x6000005f8460 [0x7fff8062d610]&gt;{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff48c84b28), context = &lt;CFArray 0x600003abfd50 [0x7fff8062d610]&gt;{type = mutable-small, count = 1, values = (</span><br><span class="line">0 : &lt;0x7f9ec100f038&gt;</span><br><span class="line">)}}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>mainRunLoop</code>的打印信息，我们发现在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>{</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ol><li><p>第一个 Observer 的activities = 0x1，即监听kCFRunLoopEntry事件，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p></li><li><p>第二个 Observer 的activities = 0xa0，即kCFRunLoopBeforeWaiting &amp; kCFRunLoopExit两个事件</p></li></ol><ul><li>kCFRunLoopBeforeWaiting时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的自动释放池并创建新池；</li><li>kCFRunLoopExit时调用 _objc_autoreleasePoolPop() 来释放自动释放池。其order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据苹果官方文档中对 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="noopener">Using Autorelease Pool Blocks</a> 的描述，我们知道在下面三种情况下是需要我们手动添加 autoreleasepool的：</p><ul><li>如果你编写的程序不是基于 UI 框架的，比如说命令行工具；</li><li>如果你编写的循环中创建了大量的临时对象；</li><li>如果你创建了一个辅助线程。当你的线程执行时，你必须尽可能快的自己创建自动释放池;</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中离屏渲染探索</title>
      <link href="/posts/303a73ce/"/>
      <url>/posts/303a73ce/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是离屏渲染？"><a href="#什么是离屏渲染？" class="headerlink" title="什么是离屏渲染？"></a>什么是离屏渲染？</h1><p>离屏渲染（offscreen-rendering）顾名思义为屏幕外的渲染，即渲染的结果不会直接呈现到当前屏幕上，而是等待合适的时机才会被显示。</p><p>正常情况下，在当前屏幕显示的内容，由 GPU 渲染完成后放到当前屏幕的帧缓存区，不需要额外的渲染空间。</p><p>假如 GPU 因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p><h1 id="离屏渲染的过程"><a href="#离屏渲染的过程" class="headerlink" title="离屏渲染的过程"></a>离屏渲染的过程</h1><p>通常的渲染流程是这样的<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-8e3671bcd114693a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在正常情况下，经过CPU的计算以及GPU的渲染之后，不停地将内容渲染完成放入<code>Frame Buffer</code>中帧缓存区，随后视频控制器会读取帧缓存区的数据，经过数模转换，再逐行显示到屏幕上</p><p>出现离屏渲染的渲染流程：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-4c0629f864bc80eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>与普通情况下 GPU 直接将渲染好的内容放入<code>Frame Buffer</code>中不同，在某些特殊情况下，需要先额外创建离屏渲染缓冲区 <code>offscreen Buffer</code>，将提前渲染好的内容放入其中，等到合适的时机再将 offscreen Buffer 中的内容进一步叠加、渲染，最后将结果切换到 Frame Buffer 中。</p><h1 id="离屏渲染的利弊"><a href="#离屏渲染的利弊" class="headerlink" title="离屏渲染的利弊"></a>离屏渲染的利弊</h1><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>特殊的渲染效果：使用额外的离屏缓冲区（offscreen butter)保存中间状态，最后叠加、处理后绘制在屏幕上，这样就不得不使用离屏渲染</li><li>效率优势：需要多次使用的效果，提前渲染存入离屏缓冲区，然后复用来提高效率。<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4></li><li>内存开支：开辟离屏缓冲区（大小不超过2.5倍屏幕像素大小）</li><li>时间和性能开支：从离屏缓冲区拷贝数据到帧缓冲区，上下文切换耗性能，容易出现掉帧的情况</li></ul><h1 id="常见的触发离屏渲染的情况"><a href="#常见的触发离屏渲染的情况" class="headerlink" title="常见的触发离屏渲染的情况"></a>常见的触发离屏渲染的情况</h1><ul><li>使用了 mask 的 layer (layer.mask)</li><li>需要进行裁剪的 layer (layer.masksToBounds /view.clipsToBounds)</li><li>设置了组透明度为 YES，并且透明度不为 1 的layer (layer.allowsGroupOpacity/ layer.opacity)</li><li>添加了投影的 layer (layer.shadow*)</li><li>采用了光栅化的 layer (layer.shouldRasterize)<blockquote><p>不过使用光栅化的时候需要注意以下几点：</p><ol><li>如果layer不能被复用，则不必打开光栅化</li><li>如果layer不是静态的，需要被频繁修改，如处于动画中，那开启离屏渲染反而会影响效率<ol start="3"><li>离屏渲染缓存内容有时间限制，缓存内容100ms内没有被使用，那么它就会丢弃，无法进行复用了</li></ol></li><li>离屏渲染缓存空间有限，不能超过2.5倍屏幕像素大小</li></ol></blockquote></li><li>绘制了文字的 layer (UILabel, CATextLayer, Core Text 等)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻iOS多线程</title>
      <link href="/posts/6322cf7d/"/>
      <url>/posts/6322cf7d/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS中的常见多线程方案"><a href="#iOS中的常见多线程方案" class="headerlink" title="iOS中的常见多线程方案"></a>iOS中的常见多线程方案</h1><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7a37d617f4fd1042.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><p>GCD中有2个用来执行任务的函数</p><ul><li>用同步的方式执行任务<br>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</li><li>用异步的方式执行任务<br>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</li></ul><p>GCD源码：<a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">https://github.com/apple/swift-corelibs-libdispatch</a></p><h4 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h4><p>GCD的队列可以分为2大类型</p><ul><li>并发队列（Concurrent Dispatch Queue）<br>可以让多个任务并发执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步函数下才有效</li><li>串行队列（Serial Dispatch Queue）<br>让任务一个接着一个地执行</li></ul><p><code>同步</code>和<code>异步</code>主要影响：能不能开启新的线程<br>同步：在<code>当前线程</code>中执行任务，<code>不具备</code>开启新线程的能力<br>异步：在<code>新的线程</code>中执行任务，<code>具备</code>开启新线程的能力</p><p><code>并发</code>和<code>串行</code>主要影响：任务的执行方式<br>并发：多个任务并发执行<br>串行：一个任务执行完毕后，再执行下一个任务</p><blockquote><p>使用<code>sync</code>函数往<code>当前串行</code>队列中添加任务，会卡住当前的串行队列（产生死锁）</p></blockquote><h1 id="GCD-Group"><a href="#GCD-Group" class="headerlink" title="GCD Group"></a>GCD Group</h1><p>下面场景如何实现？</p><ul><li>异步并发执行任务1、任务2</li><li>等任务1、任务2都执行完毕后，再回到主线程执行任务3<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_async(group, queue, ^{</span><br><span class="line">        NSLog(@"Task-1");</span><br><span class="line">    });</span><br><span class="line">    dispatch_group_async(group, queue, ^{</span><br><span class="line">        NSLog(@"Task-2");</span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^{</span><br><span class="line">        NSLog(@"Task-3");</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="iOS中的线程同步方案"><a href="#iOS中的线程同步方案" class="headerlink" title="iOS中的线程同步方案"></a>iOS中的线程同步方案</h1><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。<br>常见的解决方案：使用线程同步技术。<br>iOS中，常见的线程锁有以下几个：</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源<br>目前已经不再安全，可能会出现优先级反转问题<br>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁。</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持<br>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等<br>需要导入头文件#import &lt;os/lock.h&gt;</p><h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><p>mutex叫做<code>互斥锁</code>，等待锁的线程会处于休眠状态<br>需要导入头文件#import &lt;pthread.h&gt;</p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><p>semaphore叫做”信号量”<br>信号量的初始值，可以用来控制线程并发访问的最大数量<br>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p><code>@synchronized</code>是对mutex递归锁的封装<br>源码查看：objc4中的objc-sync.mm文件<br><code>@synchronized(obj)</code>内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p><h1 id="iOS线程同步方案性能比较"><a href="#iOS线程同步方案性能比较" class="headerlink" title="iOS线程同步方案性能比较"></a>iOS线程同步方案性能比较</h1><p>性能从高到低排序<br>os_unfair_lock<br>OSSpinLock<br>dispatch_semaphore<br>pthread_mutex<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSCondition<br>pthread_mutex(recursive)<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized</p><h1 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h1><p>-atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁<br>可以参考源码objc4的objc-accessors.mm<br>它并不能保证使用属性的过程是线程安全的</p><h1 id="iOS中的读写安全方案"><a href="#iOS中的读写安全方案" class="headerlink" title="iOS中的读写安全方案"></a>iOS中的读写安全方案</h1><ol><li>pthread_rwlock<blockquote><p>等待锁的线程会进入休眠</p></blockquote></li><li>dispatch_barrier_async<blockquote><p>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的<br>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</p></blockquote></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻runLoop</title>
      <link href="/posts/66966108/"/>
      <url>/posts/66966108/</url>
      
        <content type="html"><![CDATA[<p>顾名思义，RunLoop就是运行循环，在程序运行过程中循环做一些事情。<br>应用的一些场景：</p><ul><li>定时器（Timer）、PerformSelector</li><li>GCD Async Main Queue</li><li>事件响应、手势识别、界面刷新</li><li>网络请求</li><li>AutoreleasePool</li><li>控制线程生命周期（线程保活）</li><li>监控应用卡顿</li><li>性能优化</li></ul><p>iOS中有2套API来访问和使用RunLoop</p><ul><li>Foundation：<code>NSRunLoop</code></li><li>Core Foundation：<code>CFRunLoopRef</code></li></ul><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象，NSRunLoop是基于CFRunLoopRef的一层OC包装，CFRunLoopRef是开源的<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></p><h1 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h1><ul><li>每条线程都有唯一的一个与之对应的RunLoop对象</li><li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li><li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li><li>RunLoop会在线程结束时销毁</li><li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li></ul><h1 id="RunLoop相关的类"><a href="#RunLoop相关的类" class="headerlink" title="RunLoop相关的类"></a>RunLoop相关的类</h1><p>Core Foundation中关于RunLoop的5个类</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> {</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> {</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><ul><li>CFRunLoopModeRef代表RunLoop的运行模式</li><li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</li><li>RunLoop启动时只能选择其中一个Mode，作为currentMode</li><li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入</li><li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li><li>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</li></ul><p>常见的2种Mode</p><ul><li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</li><li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li></ul><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>{</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>可以添加Observer监听RunLoop的所有状态</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">true</span>, <span class="number">0</span>, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {</span><br><span class="line">        <span class="keyword">switch</span> (activity) {</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopEntry"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopBeforeTimers"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopBeforeSources"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopBeforeWaiting"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopAfterWaiting"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopExit"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopAllActivities:</span><br><span class="line">                NSLog(@<span class="string">"kCFRunLoopAllActivities"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    });</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">    CFRelease(observer);</span><br></pre></td></tr></tbody></table></figure><h1 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h1><ol><li>通知Observers：进入Loop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks</li><li>处理Source0（可能会再次处理Blocks）</li><li>如果存在Source1，就跳转到第8步</li><li>通知Observers：开始休眠（等待消息唤醒）</li><li>通知Observers：结束休眠（被某个消息唤醒）<ul><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ul></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作<ul><li>回到第02步</li><li>退出Loop</li></ul></li><li>通知Observers：退出Loop</li></ol><h1 id="RunLoop休眠的实现原理"><a href="#RunLoop休眠的实现原理" class="headerlink" title="RunLoop休眠的实现原理"></a>RunLoop休眠的实现原理</h1><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-c554f50c0bf115c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
            <tag> runloop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻block</title>
      <link href="/posts/d97e40db/"/>
      <url>/posts/d97e40db/</url>
      
        <content type="html"><![CDATA[<h1 id="block的本质"><a href="#block的本质" class="headerlink" title="block的本质"></a>block的本质</h1><p>block本质上也是一个OC对象，它内部也有个isa指针。<br>block是封装了函数调用以及函数调用环境的OC对象。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Created by SK on 2020/7/7.</span><br><span class="line">//  Copyright © 2020 SK. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import "Person.h"</span><br><span class="line"></span><br><span class="line">NSString *name = @"jack";</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) {</span><br><span class="line">    @autoreleasepool {</span><br><span class="line"></span><br><span class="line">        int age = 20;</span><br><span class="line">        static int sex = 0;</span><br><span class="line">        Person *person1 = [[Person alloc] init];</span><br><span class="line">        Person *person2 = [[Person alloc] init];</span><br><span class="line">        Person *person3 = [[Person alloc] init];</span><br><span class="line">        </span><br><span class="line">        __strong Person *strongPerson = person1;</span><br><span class="line">        __weak Person *weakPerson = person2;</span><br><span class="line">        __block Person *blockPerson = person3;</span><br><span class="line">        </span><br><span class="line">        void (^block)(void) = ^{</span><br><span class="line">            NSLog(@"%d-%d-%@", age, sex, name);</span><br><span class="line">            [strongPerson run];</span><br><span class="line">            [weakPerson run];</span><br><span class="line">            [blockPerson run];</span><br><span class="line">        };</span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们通过执行<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-9.0 main.m</code><br>编译一下上述代码，来看一下block的底层结构</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> {</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_blockPerson_0</span> {</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockPerson_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> Person *__strong blockPerson;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">int</span> *sex;</span><br><span class="line">  Person *__strong strongPerson;</span><br><span class="line">  Person *__weak weakPerson;</span><br><span class="line">  __Block_byref_blockPerson_0 *blockPerson; <span class="comment">// by ref</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {</span><br><span class="line">  __Block_byref_blockPerson_0 *blockPerson = __cself-&gt;blockPerson; <span class="comment">// bound by ref</span></span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> *sex = __cself-&gt;sex; <span class="comment">// bound by copy</span></span><br><span class="line">  Person *__strong strongPerson = __cself-&gt;strongPerson; <span class="comment">// bound by copy</span></span><br><span class="line">  Person *__weak weakPerson = __cself-&gt;weakPerson; <span class="comment">// bound by copy</span></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h6_tk2fn5rd5r92tqhsv84hkj540000gn_T_main_e976c4_mi_1, age, (*sex), name);</span><br><span class="line">            ((<span class="keyword">void</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)strongPerson, sel_registerName(<span class="string">"run"</span>));</span><br><span class="line">            ((<span class="keyword">void</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)weakPerson, sel_registerName(<span class="string">"run"</span>));</span><br><span class="line">            ((<span class="keyword">void</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)(blockPerson-&gt;__forwarding-&gt;blockPerson), sel_registerName(<span class="string">"run"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;strongPerson, (<span class="keyword">void</span>*)src-&gt;strongPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;weakPerson, (<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;blockPerson, (<span class="keyword">void</span>*)src-&gt;blockPerson, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;strongPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;blockPerson, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> {</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> { __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> sex = <span class="number">0</span>;</span><br><span class="line">        Person *person1 = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        Person *person2 = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        Person *person3 = ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line"></span><br><span class="line">        __attribute__((objc_ownership(strong))) Person *strongPerson = person1;</span><br><span class="line">        __attribute__((objc_ownership(weak))) Person *weakPerson = person2;</span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_blockPerson_0 blockPerson = {(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_blockPerson_0 *)&amp;blockPerson, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_blockPerson_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, person3};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;sex, strongPerson, weakPerson, (__Block_byref_blockPerson_0 *)&amp;blockPerson, <span class="number">570425344</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上述代码可以看出，block的底层结构如下：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-4880f7d553d49551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Block底层结构.png"></p><h1 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h1><p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。</p><ul><li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）<br>没有访问auto变量</li><li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）<br>访问了auto变量</li><li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）<br><strong>NSStackBlock</strong>调用了copy</li></ul><h1 id="block的变量捕获"><a href="#block的变量捕获" class="headerlink" title="block的变量捕获"></a>block的变量捕获</h1><p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-a99b237c33292d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>_NSConcreteGlobalBlock类型的block调动copy，无变化</li><li>_NSConcreteStackBlock类型的block调用copy，从栈复制到堆</li><li>_NSConcreteMallocBlock类型的block调用copy, 引用计数增加</li></ul><p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，例如：</p><ul><li>block作为函数返回值时</li><li>将block赋值给<code>__strong</code>指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul><h1 id="Auto类型变量"><a href="#Auto类型变量" class="headerlink" title="Auto类型变量"></a>Auto类型变量</h1><p>当block内部访问了对象类型的auto变量时</p><ul><li>如果block是在栈上，将不会对auto变量产生强引用</li><li>如果block被拷贝到堆上，会调用block内部的copy函数<br>copy函数内部会调用_Block_object_assign函数<br>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li><li>如果block从堆上移除，会调用block内部的dispose函数<br>dispose函数内部会调用_Block_object_dispose函数<br>_Block_object_dispose函数会自动释放引用的auto变量（release）</li></ul><h1 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h1><ul><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>__block不能修饰全局变量、静态变量（static）</li><li>编译器会将__block变量包装成一个对象</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_blockPerson_0</span> {</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockPerson_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> Person *__strong blockPerson;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="__block的内存管理"></a>__block的内存管理</h1><ul><li>当block在栈上时，并不会对__block变量产生强引用</li><li>当block被copy到堆时<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会对__block变量形成强引用（retain）</li></ul></li><li>当block从堆中移除时<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul></li></ul><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL-正方形绘制&amp;键位控制</title>
      <link href="/posts/d1292c0e/"/>
      <url>/posts/d1292c0e/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天使用OpenGL的固定存储着色器渲染正方形，并能通过键盘移动。效果如下：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-eaaa224de498e8aa.gif?imageMogr2/auto-orient/strip" alt="2020-07-08 17-31-27.2020-07-08 17_32_14.gif"></p><h1 id="正方形绘制流程"><a href="#正方形绘制流程" class="headerlink" title="正方形绘制流程"></a>正方形绘制流程</h1><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-a3f9ffc65dc0792a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenGL 正方形绘制.png"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  OpenGLDemo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by SK on 2020/7/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2020 SK. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLShaderManager.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GLTools.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLUT/GLUT.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个，着色管理器</span></span><br><span class="line">GLShaderManager shaderManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的批次容器，是GLTools的一个简单的容器类。</span></span><br><span class="line">GLBatch triangleBatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边长</span></span><br><span class="line">GLfloat blockSize = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正方形的4个点坐标</span></span><br><span class="line">GLfloat vVerts[] = {</span><br><span class="line">        -blockSize, -blockSize, <span class="number">0.0f</span>,</span><br><span class="line">        blockSize, -blockSize, <span class="number">0.0f</span>,</span><br><span class="line">        blockSize, blockSize, <span class="number">0.0f</span>,</span><br><span class="line">        -blockSize, blockSize, <span class="number">0.0f</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLfloat xPos = <span class="number">0.0f</span>;</span><br><span class="line">GLfloat yPos = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeSize</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>{</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderScene</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br><span class="line">    GLfloat vRed[] = {<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>};</span><br><span class="line">    </span><br><span class="line">    M3DMatrix44f mFinalTransform, mTransfromMatrix, mRotationMartix;</span><br><span class="line">    m3dTranslationMatrix44(mTransfromMatrix, xPos, yPos, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    //每次平移时，旋转5度</span></span><br><span class="line"><span class="comment">//    static float yRot = 0.0f;</span></span><br><span class="line"><span class="comment">//    yRot += 5.0f;</span></span><br><span class="line"><span class="comment">//    m3dRotationMatrix44(mRotationMartix, m3dDegToRad(yRot), 0.0f, 0.0f, 1.0f);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //将旋转和移动的矩阵结果 合并到mFinalTransform （矩阵相乘）</span></span><br><span class="line"><span class="comment">//    m3dMatrixMultiply44(mFinalTransform, mTransfromMatrix, mRotationMartix);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将矩阵结果 提交给固定着色器（平面着色器）中绘制</span></span><br><span class="line">    shaderManager.UseStockShader(GLT_SHADER_FLAT, mTransfromMatrix, vRed);</span><br><span class="line">    triangleBatch.Draw();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行交换缓存区</span></span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">specialKeys</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    GLfloat stepSize = <span class="number">0.025f</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_UP) {</span><br><span class="line">        yPos += stepSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_DOWN) {</span><br><span class="line">        yPos -= stepSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_LEFT) {</span><br><span class="line">        xPos -= stepSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == GLUT_KEY_RIGHT) {</span><br><span class="line">        xPos += stepSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//碰撞检测</span></span><br><span class="line">    <span class="keyword">if</span> (xPos &lt; (<span class="number">-1.0f</span> + blockSize)) {</span><br><span class="line">        xPos = <span class="number">-1.0f</span> + blockSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (xPos &gt; (<span class="number">1.0f</span> - blockSize)) {</span><br><span class="line">        xPos = <span class="number">1.0f</span> - blockSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (yPos &lt; (<span class="number">-1.0f</span> + blockSize)) {</span><br><span class="line">        yPos = <span class="number">-1.0f</span> + blockSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (yPos &gt; (<span class="number">1.0f</span> - blockSize)) {</span><br><span class="line">        yPos = <span class="number">1.0f</span> - blockSize;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupRC</span><span class="params">()</span> </span>{</span><br><span class="line">    glClearColor(<span class="number">0.98f</span>, <span class="number">0.40f</span>, <span class="number">0.7f</span>, <span class="number">1.0</span>);</span><br><span class="line">    shaderManager.InitializeStockShaders();</span><br><span class="line">    </span><br><span class="line">    triangleBatch.Begin(GL_TRIANGLE_FAN, <span class="number">4</span>);</span><br><span class="line">    triangleBatch.CopyVertexData3f(vVerts);</span><br><span class="line">    triangleBatch.End();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    `GLTools`函数`glSetWorkingDrectory`用来设置当前工作目录。实际上在Windows中是不必要的，因为工作目录默认就是与程序可执行执行程序相同的目录。但是在Mac OS X中，这个程序将当前工作文件夹改为应用程序捆绑包中的`/Resource`文件夹。`GLUT`的优先设定自动进行了这个中设置，但是这样中方法更加安全。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    gltSetWorkingDirectory(argv[<span class="number">0</span>]);</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL);</span><br><span class="line">    glutInitWindowSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    glutCreateWindow(<span class="string">"OpenGL Demo"</span>);</span><br><span class="line">    glutReshapeFunc(changeSize);</span><br><span class="line">    glutDisplayFunc(renderScene);</span><br><span class="line">    glutSpecialFunc(specialKeys);</span><br><span class="line">    </span><br><span class="line">    GLenum err = glewInit();</span><br><span class="line">    <span class="keyword">if</span> (err != GLEW_OK) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glew error: %s\n"</span>, glewGetErrorString(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    setupRC();</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻OC关联对象</title>
      <link href="/posts/1d04a2cc/"/>
      <url>/posts/1d04a2cc/</url>
      
        <content type="html"><![CDATA[<h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><p>关联对象常用的API如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> * key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                id value, objc_AssociationPolicy policy)</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> * key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></tbody></table></figure><p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Person (Extension)</span><br><span class="line"></span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person (Extension)</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name {</span><br><span class="line">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (NSString *)name {</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h1><p>实现关联对象技术的核心对象有</p><ul><li><code>AssociationsManager</code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> {</span></span><br><span class="line">    <span class="keyword">using</span> Storage = ExplicitInitDenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt;;</span><br><span class="line">    <span class="keyword">static</span> Storage _mapStorage; <span class="comment">// AssociationsHashMap</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><code>AssociationsHashMap</code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; AssociationsHashMap;</span><br></pre></td></tr></tbody></table></figure></li><li><code>ObjectAssociationMap</code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, ObjcAssociation&gt; ObjectAssociationMap;</span><br></pre></td></tr></tbody></table></figure></li><li><code>ObjcAssociation</code><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> {</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">    id _value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>关联对象的原理：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-578a627de0b75b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h1 id="Runtime源码分析"><a href="#Runtime源码分析" class="headerlink" title="Runtime源码分析"></a>Runtime源码分析</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">{</span><br><span class="line">    ObjcAssociation association{};</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) {</span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.<span class="built_in">end</span>()) {</span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised{(objc_object *)object};</span><br><span class="line">    ObjcAssociation association{policy, value};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.<span class="built_in">get</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) {</span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.try_emplace(disguised, ObjectAssociationMap{});</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) {</span><br><span class="line">                <span class="comment">/* it's the first association we make */</span></span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* establish or replace the association */</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            <span class="keyword">auto</span> result = refs.try_emplace(key, <span class="built_in">std</span>::<span class="built_in">move</span>(association));</span><br><span class="line">            <span class="keyword">if</span> (!result.second) {</span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) {</span><br><span class="line">                <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) {</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="关联对象实现weak"><a href="#关联对象实现weak" class="headerlink" title="关联对象实现weak"></a>关联对象实现weak</h1><p>associated object 本身并不支持添加具备 weak 特性的 property，但我们可以通过一个小技巧来完成，下面是一个简单的实现代码</p><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setKey:(<span class="built_in">NSObject</span>*)object {</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakObject = object;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = ^{ <span class="keyword">return</span> weakObject; };</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(key), block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span>*)key {</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">id</span> curContext = block ? block() : <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> curContext;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻Category</title>
      <link href="/posts/b68ef59d/"/>
      <url>/posts/b68ef59d/</url>
      
        <content type="html"><![CDATA[<h1 id="Category的底层结构"><a href="#Category的底层结构" class="headerlink" title="Category的底层结构"></a>Category的底层结构</h1><p>在源码的中，我们可以查看到Category的底层结构（<code>objc-runtime-new.h</code>）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> {</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protocol_list_t</span> *<span class="title">protocolsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>Category的底层结构是<code>struct category_t</code>，里面包含了<code>instanceMethods</code>,<code>classMethods</code>, <code>protocols</code>, <code>instanceProperties</code>,  <code>_classProperties</code>。<br>我们平时使用categroy添加对象方法、类方法、协议、属性都有相对应的数据结构存储。但是我们发现<code>category_t</code>中没有成员变量数据结构，这也是分类中是不允许添加成员变量的原因（可以通过runtime的关联对象实现）。Category中添加的属性不会自动生成成员变量，只会生成<code>get</code>、<code>set</code>方法的声明，需要我们自己去实现。</p><h1 id="Category的加载过程"><a href="#Category的加载过程" class="headerlink" title="Category的加载过程"></a>Category的加载过程</h1><p>我们都知道，runtime在启动的时候才会加载Category,下面我们通过源码来看一下Category的加载流程。<br>首先我们先看一下runtime的初始化代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line">    cache_init();</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>map_images</code>-&gt;<code>map_images_nolock</code>-&gt;<code>_read_images</code>-&gt;<code>load_categories_nolock</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>{</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc{cat, hi};</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) {</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) {</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isStubClass()) {</span><br><span class="line">                <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">                <span class="comment">// don't know their metaclass until they're</span></span><br><span class="line">                <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">                <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">                <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">                <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                {</span><br><span class="line">                    objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">                <span class="comment">// Then, rebuild the class's method lists (etc) if</span></span><br><span class="line">                <span class="comment">// the class is realized.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                    ||  cat-&gt;instanceProperties)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;isRealized()) {</span><br><span class="line">                        attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                    ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) {</span><br><span class="line">                        attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    processCatlist(_getObjc2CategoryList(hi, &amp;count));</span><br><span class="line">    processCatlist(_getObjc2CategoryList2(hi, &amp;count));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">attachCategories(Class cls, <span class="keyword">const</span> <span class="keyword">locstamped_category_t</span> *cats_list, <span class="keyword">uint32_t</span> cats_count,</span><br><span class="line">                 <span class="keyword">int</span> flags)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintReplacedMethods)) {</span><br><span class="line">        printReplacements(cls, cats_list, cats_count);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintConnecting)) {</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: attaching %d categories to%s class '%s'%s"</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">" existing"</span> : <span class="string">""</span>,</span><br><span class="line">                     cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? <span class="string">" (meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Only a few classes have more than 64 categories during launch.</span></span><br><span class="line"><span class="comment">     * This uses a little stack, and avoids malloc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Categories must be added in the proper order, which is back</span></span><br><span class="line"><span class="comment">     * to front. To do that with the chunking, we iterate cats_list</span></span><br><span class="line"><span class="comment">     * from front to back, build up the local buffers backwards,</span></span><br><span class="line"><span class="comment">     * and call attachLists on the chunks. attachLists prepends the</span></span><br><span class="line"><span class="comment">     * lists, so the final result is in the expected order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) {</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) {</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) {</span><br><span class="line">                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">                rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) {</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) {</span><br><span class="line">                rwe-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocolsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) {</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) {</span><br><span class="line">                rwe-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) {</span><br><span class="line">        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);</span><br><span class="line">        rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) flushCaches(cls);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Load方法"><a href="#Load方法" class="headerlink" title="+Load方法"></a>+Load方法</h1><ul><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li></ul><p>调用顺序：</p><ol><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的+load之前会先调用父类的+load</li></ul><ol start="2"><li>再调用分类的+load</li></ol><ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ol><blockquote><p>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</p></blockquote><h2 id="Load的加载流程"><a href="#Load的加载流程" class="headerlink" title="Load的加载流程"></a>Load的加载流程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) {</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) {</span><br><span class="line">            call_class_loads();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    } <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> *<span class="title">cats</span> = <span class="title">loadable_categories</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) {</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">                _objc_inform(<span class="string">"LOAD: +[%s(%s) load]\n"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            }</span><br><span class="line">            (*load_method)(cls, @selector(load));</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) {</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) {</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            shift++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) {</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) {</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                <span class="built_in">realloc</span>(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(struct loadable_category));</span><br><span class="line">        }</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="keyword">if</span> (used) {</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) {</span><br><span class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) {</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: %d categories still waiting for +load\n"</span>,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h1><p>+initialize方法会在类第一次接收到消息时调用。<br>先调用父类的+initialize，再调用子类的+initialize，每个类只会初始化1次。</p><p>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点：</p><ul><li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li><li>如果分类实现了+initialize，就覆盖类本身的+initialize调用<h2 id="Initialize的流程"><a href="#Initialize的流程" class="headerlink" title="Initialize的流程"></a>Initialize的流程</h2><code>objc_msgSend</code>-&gt;<code>class_getInstanceMethod</code>-&gt;<code>lookUpImpOrForward</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeNonMetaClass</code><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li></ul><p>Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息<br>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻KVO &amp; KVC</title>
      <link href="/posts/edbcd340/"/>
      <url>/posts/edbcd340/</url>
      
        <content type="html"><![CDATA[<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><blockquote><h3 id="KVO的本质是什么？"><a href="#KVO的本质是什么？" class="headerlink" title="KVO的本质是什么？"></a>KVO的本质是什么？</h3><p>KVO的全称是Key-Value Observing，可以用于监听某个对象属性值的改变。<br>主要使用下面几个方法：</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></tbody></table></figure><p>我们自定义一个Person对象，我们通过给Person对象添加KVO监听，来观察添加KVO前后的变化，见下图：<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-19ee7654a5b769cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从打印结果我们可以看到：</p><ul><li>person1的类对象改变成了<code>NSKVONotifying_Person</code></li><li>通过输出方法的地址，我们发现添加KVO之后，实际调用的是<code>Foundation _NSSetIntValueAndNotify</code><br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-95f6ce87a552dddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><strong>下图是KVO实现的伪代码</strong><br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7277e53a2e4df56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们发现，当对象通过KVO监听属性变化时，会利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>当修改instance对象的属性时，</p><ul><li>会调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数</li><li><code>willChangeValueForKey:</code></li><li><code>父类原来的setter</code></li><li><code>didChangeValueForKey:</code>内部会触发监听器（Oberser）的监听方法( <code>observeValueForKeyPath:ofObject:change:context:</code>）</li></ul><p>如何手动触发KVO？</p><blockquote><p>手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></blockquote><p>直接修改成员变量会触发KVO么？</p><blockquote><p>不会触发KVO</p></blockquote><h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性，常见的API如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key;</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-12fbc634fad637a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-9f8740eba418b2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL初探</title>
      <link href="/posts/7c1e6eee/"/>
      <url>/posts/7c1e6eee/</url>
      
        <content type="html"><![CDATA[<h1 id="图形API简介"><a href="#图形API简介" class="headerlink" title="图形API简介"></a>图形API简介</h1><ul><li><strong>OpenGL (Open Graphics Library)</strong>是一个跨编程语言、跨平台的编程图形程序接口，它将计算机的资源抽象成为一个OpenGL的对象，对这些资源的操作抽象为⼀个个的<strong>OpenGL</strong>指令</li><li><strong>OpenGL ES (OpenGL for Embedded Systems)</strong>是 OpenGL 三维图形 API 的子集，针对手机、 PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。</li><li><strong>DirectX</strong> 是由很多API组成的，DirectX并不是一个单纯的图形API. 最重要的是DirectX是属于 Windows上一个多媒体处理框架.并不支持Windows以外的平台,所以不是跨平台框架. 按照性质分类，可以分为四⼤部分，显示部分、声音部分、输入部分和网络部分.</li><li><strong>Metal</strong>: Apple为游戏开发者推出了新的平台技术 Metal，该技术能够为 3D 图像提高 10 倍的渲染性能.Metal 是Apple为了解决3D渲染而推出的框架。</li></ul><h3 id="图形API目的是解决什么问题"><a href="#图形API目的是解决什么问题" class="headerlink" title="图形API目的是解决什么问题"></a>图形API目的是解决什么问题</h3><blockquote><p>OpenGL /OpenGL ES/ Metal 在任何项目中解决问题的本质就是利用GPU芯片来高效渲染图形图像.<br>图形API 是iOS开发者唯一接近GPU的方式. </p></blockquote><ul><li>游戏开发中,对于游戏场景/游戏人物的渲染</li><li>⾳视频开发中,对于视频解码后的数据渲染</li><li>地图引擎,对于地图上的数据渲染</li><li>动画中,实现动画的绘制</li><li>视频处理中,对于视频加上滤镜效果</li></ul><h1 id="OpenGL专业名词"><a href="#OpenGL专业名词" class="headerlink" title="OpenGL专业名词"></a>OpenGL专业名词</h1><h3 id="OpenGL上下文（Context）"><a href="#OpenGL上下文（Context）" class="headerlink" title="OpenGL上下文（Context）"></a>OpenGL上下文（Context）</h3><ul><li>在应用程序调用任何OpenGL的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是⼀个⾮常庞大的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执行的基础</li><li>OpenGL的函数不管在哪个语言中，都是类似C语言一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然你得首先把这个对象设置为当前对象。因此，通过OpenGL指令的封装，是可以将OpenGL的相关调用封装成为一个面向对象的图形API</li><li>由于OpenGL上下文是⼀个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的⽅案，会比反复切换上下文，或者⼤量修改渲染状态，更加合理高效的.</li></ul><h3 id="OpenGL状态机"><a href="#OpenGL状态机" class="headerlink" title="OpenGL状态机"></a>OpenGL状态机</h3><p>状态机是理论上的一种机器。描述了⼀个对象在其生命周期内所经历的各种状态，状态间的转变，发⽣生转变的动因，条件及转变中所执⾏行行的活动。或者说状态机是 ⼀种行为，说明对象在其生命周期中响应事件所经历的状态序列以及对那些状态事件的响应。因此具有以下特点:</p><ul><li>有记忆功能，能记住其当前的状态</li><li>可以接收输入，根据输入的内容和⾃己的原先状态，修改⾃己当前状态，并且可以有对应输出</li><li>当进入特殊状态(停机状态)的时候，变不不再接收输入，停⽌工作</li></ul><p>类推到OpenGL 中来,可以这么理解:</p><ul><li>OpenGL可以记录⾃己的状态(如当前所使用的颜色、是否开启了混合功能等)</li><li>OpenGL可以接收输入(当调用OpenGL函数的时候，实际上可以看成 OpenGL在接收我们的输入)，如我们调用glColor3f，则OpenGL接收到这个输入后会修改⾃己的“当前颜色”这个状态</li><li>OpenGL可以进入停止状态，不再接收输入。在程序退出前，OpenGL总会先停止工作的</li></ul><h3 id="渲染（Rendering）"><a href="#渲染（Rendering）" class="headerlink" title="渲染（Rendering）"></a>渲染（Rendering）</h3><p>就是将图像和图形数据转换成3D空间图像的操作。</p><h3 id="顶点数组（VertexArray）-amp-顶点缓冲区（VertexBuffer）"><a href="#顶点数组（VertexArray）-amp-顶点缓冲区（VertexBuffer）" class="headerlink" title="顶点数组（VertexArray）&amp; 顶点缓冲区（VertexBuffer）"></a>顶点数组（VertexArray）&amp; 顶点缓冲区（VertexBuffer）</h3><ul><li>画图一般是先画好图像的⻣架，然后再往骨架里面填充颜⾊，这对于 OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGL ES中，有3种类型的图元：<strong>点</strong>、<strong>线</strong>、<strong>三⻆形</strong>。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。⽽性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区</li><li>顶点指的是我们在绘制⼀个图形时,它的顶点位置数据.⽽这个数据可以直接存储在数组中或者将其缓存到GPU内存中<h3 id="管线"><a href="#管线" class="headerlink" title="管线"></a>管线</h3>管线可以理解为渲染流水线。在OpenGL下渲染图形的时候，显卡在处理数据时是按照一个固定的顺序，类似于流水线般，按照先后顺序一个接一个的执行。而且必须严格按照这个顺序，不能打破。<h3 id="固定管线-存储着色器"><a href="#固定管线-存储着色器" class="headerlink" title="固定管线/存储着色器"></a>固定管线/存储着色器</h3></li><li>在早期的OpenGL 版本,它封装了很多种着色器程序块内置的一段包含了光照、坐标变换、裁剪等诸多功能的固定shader程序来完成，来帮助开发者来完成图形的渲染。而开发者只需要传入相应的参数,就能快速完成图形的渲染。类似于iOS开发会封装很多API,而我们只需要调⽤,就可以实现功能。不需要关注底层实现原理</li><li>但是由于OpenGL 的使⽤用场景非常丰富，固定管线或存储着色器器⽆法完成每⼀个业务.这时将相关部分开放成可编程</li></ul><h3 id="着色器程序Shader"><a href="#着色器程序Shader" class="headerlink" title="着色器程序Shader"></a>着色器程序Shader</h3><p>着色器（Shader）是用来实现图像渲染的，用来替代固定渲染管线的可编辑程序，即是可编程渲染管线。因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编辑成的着色器程序。<br>常见的着色器主要有：顶点着色器(VertexShader)，片段着色器(FragmentShader)/像素着色器(PixelShader)<br>，几何着色器(GeometryShader)，曲面细分着色器(TessellationShader)。最重要的是顶点着色器和片段着色器。<br>OpenGL在处理shader的时候，通过编译，链接等步骤，生成着色器程序(glProgram),着色器程序同时包含了顶点着色器和片断着色器的运算逻辑。在OpenGL进行渲染的时候，首先由顶点着色器对传入的顶点数据进行计算，再通过图元装配，将顶点转换为图元，然后进行光栅化，将图元转换为栅格化数据，最后，将栅格化数据传入片段着色器中进行计算，片段着色器会对栅格化数据中的每一个像素进行计算，并决定像素的颜色。</p><h3 id="顶点着色器VertexShader"><a href="#顶点着色器VertexShader" class="headerlink" title="顶点着色器VertexShader"></a>顶点着色器VertexShader</h3><ul><li>一般⽤来处理理图形每个顶点变换(旋转/平移/投影等)</li><li>顶点着色器是OpenGL中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着⾊器运算过程中⽆法访问其他顶点的数据</li><li>一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这里发⽣的。<h3 id="片元着色器-FragmentShader"><a href="#片元着色器-FragmentShader" class="headerlink" title="片元着色器 FragmentShader"></a>片元着色器 FragmentShader</h3></li><li>一般⽤来处理图形中每个像素点颜色计算和填充</li><li>片段着色器是OpenGL中⽤于计算片段(像素)颜色的程序。片段着⾊色器是逐像素运算的程序，也就是说每个像素都会执行⼀次片段着⾊色器，当然也是并行的<h3 id="GLSL（OpenGL-Shading-language"><a href="#GLSL（OpenGL-Shading-language" class="headerlink" title="GLSL（OpenGL Shading language)"></a>GLSL（OpenGL Shading language)</h3>OpenGL着色语言（OpenGL Shading language)是用来在OpenGl中着色编程的语言，类似于C语言。他们是在图形卡的GPU（Graphic Proccessor Unit图形处理单元）上执行的。代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。比如：视图转换、投影转换等。GLSL的着色器代码分成两个部分：顶点着色器和片段着色器</li></ul><h3 id="光栅化Rasterization"><a href="#光栅化Rasterization" class="headerlink" title="光栅化Rasterization"></a>光栅化Rasterization</h3><ul><li>是把顶点数据转换成片元的过程，具有将图转化成为一个个栅格组成的图像的作用。特点是每个元素对应帧缓冲区中的一个像素。</li><li>光栅化就是把顶点数据转换为片元的过程。片元中的每一个元素对应于帧缓冲区中的一个像素</li><li>光栅化其实是一种将几何图元变为二维图像的过程。该过程包含了两部分的工作。第一部分工作：决定了窗口坐标中哪些整型格栅区域被基本图元占用。第二部分工作：分配一个颜色值和一个深度值到各个区域。光栅化过程产生的是片元。</li><li>把物体的数学描述以及与物体相关的颜色信息转换为屏幕上用于对应位置的像素及⽤于填充像素的颜色，这个过程称为光栅化，这是一个将模拟信号转化为离散信号的过程</li></ul><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纹理可以理解为一个图片，也就是位图。⼤家在渲染图形时需要在其编码填充图⽚,为了使得场景更加逼真.⽽这里使⽤的图片,就是常说的纹理.但是在OpenGL,我们更加习惯叫纹理,⽽不是图片。</p><h3 id="混合（Blending）"><a href="#混合（Blending）" class="headerlink" title="混合（Blending）"></a>混合（Blending）</h3><p>在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上的颜色进行混合，混合的算法可以通过OpenGL的函数进行指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合 算法，⼀般可以通过像素着⾊器进行实现，当然性能会比原生的混合算法差一些。</p><h3 id="变换矩阵-Transformation"><a href="#变换矩阵-Transformation" class="headerlink" title="变换矩阵(Transformation)"></a>变换矩阵(Transformation)</h3><p>在图形绘制过程中，有三种变换，分别是平移，缩放，旋转。就需要使用变换矩阵。</p><h3 id="投影矩阵（Projection）"><a href="#投影矩阵（Projection）" class="headerlink" title="投影矩阵（Projection）"></a>投影矩阵（Projection）</h3><p>⽤于将3D坐标转换为二维屏幕坐标,实际线条也将在二维坐标下进行绘制。</p><h3 id="渲染上屏-交换缓冲区-SwapBuffer"><a href="#渲染上屏-交换缓冲区-SwapBuffer" class="headerlink" title="渲染上屏/交换缓冲区(SwapBuffer)"></a>渲染上屏/交换缓冲区(SwapBuffer)</h3><p>渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。要注意的是，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像。<br>为了解决这个问题，常规的OpenGL程序至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。<br>由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步。</p><p>使⽤了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高⽔水平。为了解决这个问题，引⼊了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，⽽垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探寻OC对象的本质</title>
      <link href="/posts/5b1f4837/"/>
      <url>/posts/5b1f4837/</url>
      
        <content type="html"><![CDATA[<p>本文主要通过三个问题，一起探寻一下OC对象实现的底层原理。</p><blockquote><h1 id="一个NSObject对象占用多少内存？"><a href="#一个NSObject对象占用多少内存？" class="headerlink" title="一个NSObject对象占用多少内存？"></a>一个NSObject对象占用多少内存？</h1></blockquote><h2 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h2><p>我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-fd87193d047fe1a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>其实Objective-C的面向对象都是基于C\C++的<strong>结构体</strong>实现的。<br>我们可以通过下面的命令将Objective-C代码转换为C\C++代码来看一下具体的实现。</p><blockquote><p><code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  main.m  -o  main-arm64.cpp</code></p></blockquote><p>OC代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) {</span><br><span class="line">    @autoreleasepool {</span><br><span class="line">        NSObject *object = [[NSObject alloc] init];</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>转换的C++文件<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-199b72274a35ec1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们都知道每个OC对象都包含一个<code>isa</code>指针，在NSObject的头文件中，我们可以看到如下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Wobjc-interface-ivars"</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>在转换的C++代码中，我们也可以看到类似的结构体：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> {</span></span><br><span class="line">Class isa;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSArray_IMPL</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSString_IMPL</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSDictionary_IMPL</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>不难猜想，<code>struct NSObject_IMPL</code>其实就是NSObject的底层实现。</p><h4 id="我们思考一下，一个OC对象在内存中是如何布局的？"><a href="#我们思考一下，一个OC对象在内存中是如何布局的？" class="headerlink" title="我们思考一下，一个OC对象在内存中是如何布局的？"></a>我们思考一下，一个OC对象在内存中是如何布局的？</h4><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-f556da873ae6283b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>NSObject其实就是结构体<code>struct NSObject_IMPL</code>，包含了一个<code>isa</code>指。在64位架构下，一个指针地址占用8个字节，是不是NSObjec对象所占用的内存就是8个字节呢？下面我们通过几种方法验证一下。</p><ol><li><p>使用runtime里的<code>class_getInstanceSize ()</code>方法，获得NSObject实例对象的成员变量所占用的大小。<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-da96cd9d0b8e1af9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>使用<code>malloc_size()</code>，获得obj指针所指向内存的大小。<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-df83debe2a7f4907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><p>为什么两次结果会截然不同呢？我们看一下<code>class_getInstanceSize</code>的具体实现。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May be unaligned depending on class's ivars.</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        ASSERT(isRealized());</span><br><span class="line">        <span class="keyword">return</span> data()-&gt;ro()-&gt;instanceSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 7UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">word_align</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">word_align</span><span class="params">(<span class="keyword">size_t</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">align16</span><span class="params">(<span class="keyword">size_t</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="keyword">size_t</span>(<span class="number">15</span>)) &amp; ~<span class="keyword">size_t</span>(<span class="number">15</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从源码里我们可以看到，系统在计算分配内存的时进行了字节对齐。<br>64位系统下<code>define WORD_MASK 7UL</code></p><blockquote><p>假设环境是64位机器， 传进来的数字是2<br>   return (2 + 7) &amp; (<del>7);<br>   return (0000 1001) &amp; (</del>0000 0111);<br>   return (0000 1001) &amp; (1111 1000) = (0000 1000)<br>   在计算机中， 位运算效率很高。</p></blockquote><h4 id="那为什么通过malloc-size-方法获取的是16个字节呢？"><a href="#那为什么通过malloc-size-方法获取的是16个字节呢？" class="headerlink" title="那为什么通过malloc_size ()方法获取的是16个字节呢？"></a>那为什么通过<code>malloc_size ()</code>方法获取的是16个字节呢？</h4><p>我们知道OC中创建一个对象需要调用<code>alloc</code>方法，下面我们通过设定一个符号断电<code>objc_alloc_init</code>看一下实际的调用堆栈。<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-9a6f781173650ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>通过调用堆栈信息，我们发现<code>alloc</code>方法会调用<code>_objc_rootAllocWithZone</code>方法，下面我们看一下这个方法的具体实现：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="keyword">malloc_zone_t</span> *zone __unused)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_createInstance</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: none</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note: this function has been carefully written so that the fastpath</span></span><br><span class="line"><span class="comment">* takes no branch.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="keyword">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">{</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) {</span><br><span class="line">        obj = (id)malloc_zone_calloc((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) {</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) {</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) {</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) {</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们发现，系统为对象开辟内存空间实际调用的是这个<code>obj = (id)calloc(1, size);</code>，这里的<code>size</code>是需要分配的内存的大小。</p><blockquote><p><code>size = cls-&gt;instanceSize(extraBytes);</code></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (fastpath(cache.hasFastInstanceSize(extraBytes))) {</span><br><span class="line">            <span class="keyword">return</span> cache.fastInstanceSize(extraBytes);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>通过代码，我们不难发现，CF框架内部规定：当创建一个实例对象的时候，为其分配的空间不能小于16个字节。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>系统分配了16个字节给NSObject对象（通过malloc_size函数获得）<br>但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）</p><hr><blockquote><h1 id="对象的isa指针指向哪里？"><a href="#对象的isa指针指向哪里？" class="headerlink" title="对象的isa指针指向哪里？"></a>对象的isa指针指向哪里？</h1><h1 id="OC的类信息存放在哪里？"><a href="#OC的类信息存放在哪里？" class="headerlink" title="OC的类信息存放在哪里？"></a>OC的类信息存放在哪里？</h1></blockquote><h2 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h2><p>Objective-C中的对象，简称OC对象，主要可以分为3种</p><ul><li>instance对象（实例对象）</li><li>class对象（类对象）</li><li>meta-class对象（元类对象）</li></ul><h2 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h2><p>instance对象就是通过类<code>alloc</code>出来的对象，每次调用<code>alloc</code>都会产生新的instance对象。<code>NSObject *obj = [[NSObject alloc] init];</code></p><p>instance对象在内存中存储的信息包括:</p><ul><li><code>isa</code>指针</li><li>其他成员变量</li></ul><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSObject *object1 = [[NSObject alloc] init];</span><br><span class="line">NSObject *object2 = [[NSObject alloc] init];    </span><br><span class="line">Class objectClass1 = [object1 class];</span><br><span class="line">Class objectClass2 = [object2 class];</span><br><span class="line">Class objectClass3 = object_getClass(object1);</span><br><span class="line">Class objectClass4 = object_getClass(object2);</span><br><span class="line">Class objectClass5 = [NSObject class];</span><br></pre></td></tr></tbody></table></figure><p>objectClass1 ~ objectClass5都是NSObject的class对象（类对象），每个类在内存中有且只有一个class对象。</p><p>class对象在内存中存储的信息主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（@property）、类的对象方法信息（instance method）</li><li>类的协议信息（protocol）、类的成员变量信息（ivar）</li><li>……</li></ul><h2 id="meta-class"><a href="#meta-class" class="headerlink" title="meta-class"></a>meta-class</h2><figure class="highlight objc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class objectMetaClass = object_getClass(objectClass5);</span><br></pre></td></tr></tbody></table></figure><p>objectMetaClass是NSObject的meta-class对象（元类对象），每个类在内存中有且只有一个meta-class对象。<br>meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的类方法信息（class method）</li><li>……</li></ul><p><code>class_isMetaClass()</code>查看Class是否为meta-class</p><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7a6519ccf6378742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>instance的isa指向class</li><li>class的isa指向meta-class</li><li>meta-class的isa指向基类的meta-class</li><li>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</li><li>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</li><li>instance调用对象方法的轨迹<br>isa找到class，方法不存在，就通过superclass找父类</li><li>class调用类方法的轨迹<br>isa找meta-class，方法不存在，就通过superclass找父类</li></ul><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-086ca7c0da316287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>从64bit开始，isa需要进行一次位运算，才能计算出真实地址。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br></pre></td></tr></tbody></table></figure><h2 id="struct-objc-class的结构"><a href="#struct-objc-class的结构" class="headerlink" title="struct objc_class的结构"></a>struct objc_class的结构</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object {</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    }</span><br><span class="line">....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_ext_t</span> {</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> {</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint16_t</span> witness;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint16_t</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; ro_or_rw_ext;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-f087ecea3ee01385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>对象的isa指针指向哪里？<br>instance对象的isa指向class对象<br>class对象的isa指向meta-class对象<br>meta-class对象的isa指向基类的meta-class对象</p></blockquote><blockquote><p>OC的类信息存放在哪里？<br>对象方法、属性、成员变量、协议信息，存放在class对象中<br>类方法，存放在meta-class对象中<br>成员变量的具体值，存放在instance对象</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-常见的排序算法</title>
      <link href="/posts/f6f7bedd/"/>
      <url>/posts/f6f7bedd/</url>
      
        <content type="html"><![CDATA[<p><strong>排序</strong>（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素的任一序列，重新排列成一个按关键字有序的序列。<br>由于待排序的记录数量不同，使得排序过程中设计的存储器不同，可将排序方法分为两大类：</p><ul><li><strong>内部排序</strong>，指的是待排序记录存放在计算机存储器中进行的排序过程；</li><li><strong>外部排序</strong>，指的是待排序记录的数据量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序(Bubble Sort) 一种交换排序,它的基本思想就是: 两两⽐相邻的记录的关键字,如果 反序则交换,直到没有反序的记录为止。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序-对顺序表L进行交换排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort0</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length; j++) {</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j]) {</span><br><span class="line">                swap(L, i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序-对顺序表L作冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = L-&gt;length; j &gt; i; j--) {</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[j - <span class="number">1</span>] &gt; L-&gt;r[j]) {</span><br><span class="line">                swap(L, j - <span class="number">1</span>, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序-对顺序表L冒泡排序进行优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    Status flag = TRUE;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length &amp;&amp; flag; i++) {</span><br><span class="line">        flag = FALSE;</span><br><span class="line">        <span class="keyword">for</span> (j = L-&gt;length; j &gt; i; j--) {</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[j - <span class="number">1</span>] &gt; L-&gt;r[j]) {</span><br><span class="line">                swap(L, j - <span class="number">1</span>, j);</span><br><span class="line">                flag = TRUE;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="简单选择排序算法-Simple-Selection-Sort"><a href="#简单选择排序算法-Simple-Selection-Sort" class="headerlink" title="简单选择排序算法(Simple Selection Sort)"></a>简单选择排序算法(Simple Selection Sort)</h2><p>简单选择排序算法 就是通过<code>n - i</code>次关键词比较,从<code>n - i + 1</code>个记录中找出关键字最小的记录,并和第<code>i</code>(1 &lt;= i &lt;= n) 个记录进行交换。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序--对顺序表L进行简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, <span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;length; i++) {</span><br><span class="line">        <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length; j++) {</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[<span class="built_in">min</span>] &gt; L-&gt;r[j]) {</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="built_in">min</span>) {</span><br><span class="line">            swap(L, i, <span class="built_in">min</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><strong>直接插入排序</strong>（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作使将一个记录插入已排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序算法--对顺序表L进行直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L-&gt;length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="number">1</span>]) {</span><br><span class="line">            L-&gt;r[<span class="number">0</span>] = L-&gt;r[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; L-&gt;r[<span class="number">0</span>] &lt; L-&gt;r[j]; j--) {</span><br><span class="line">                L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[j];</span><br><span class="line">            }</span><br><span class="line">            L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>希尔排序又称“最小增量排序”，它也是一种属插入排序类的方法，但在实际效率上较前述集中排序方法有较大的改进。<br>希尔排序的一个特点是：子序列的构成不是简单地“逐段分割”，而是将像个某个“增量”的记录组成一个子序列。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序-对顺序表L希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> increment = L-&gt;length;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        increment = increment / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = increment + <span class="number">1</span>; i &lt;= L-&gt;length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment]) {</span><br><span class="line">                L-&gt;r[<span class="number">0</span>] = L-&gt;r[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i - increment; j &gt; <span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>] &lt; L-&gt;r[j]; j -= increment) {</span><br><span class="line">                    L-&gt;r[j + increment] = L-&gt;r[j];</span><br><span class="line">                }</span><br><span class="line">                L-&gt;r[j + increment] = L-&gt;r[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">while</span> (increment &gt; <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><strong>堆排序</strong> 就是利用堆进行排序的算法。它的基本思想：</p><ol><li>将待排序的序列构成⼀个⼤顶堆，此时整个序列的最大值就堆顶的根结点，将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值);</li><li>然后将剩余的<code>n - 1</code>个序列重新构成一个堆，这样就会得到<code>n</code>个元素的次大值, 如此重复执行，就能得到一个有序列了；</li></ol><p>每个结点的值都⼤于或等于其左右孩⼦子结点的值, 称为<strong>大顶堆</strong>。<br>每个结点的值都小于或等于其左右孩⼦子结点的值, 称为<strong>小顶堆</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 大顶堆调整函数;</span></span><br><span class="line"><span class="comment"> 条件: 在L.r[s...m] 记录中除了下标s对应的关键字L.r[s]不符合大顶堆定义,其他均满足;</span></span><br><span class="line"><span class="comment"> 结果: 调整L.r[s]的关键字,使得L-&gt;r[s...m]这个范围内符合大顶堆定义.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAjust</span><span class="params">(SqList *L, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line">    temp = L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="number">1</span>]) {</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= L-&gt;r[j]) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        L-&gt;r[s] = L-&gt;r[j];</span><br><span class="line">        s = j;</span><br><span class="line">    }</span><br><span class="line">    L-&gt;r[s] = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = L-&gt;length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">        HeapAjust(L, i, L-&gt;length);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (i = L-&gt;length; i &gt; <span class="number">1</span>; i--){</span><br><span class="line">        swap(L, <span class="number">1</span>, i);</span><br><span class="line">        HeapAjust(L, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-散列表查找</title>
      <link href="/posts/5734cf9a/"/>
      <url>/posts/5734cf9a/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h1><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p><p>散列技术是记录的存储位置和它的关键字之间建立一个确定的对应关系t，使得每个关键字key对应一个存储位置f(key)。当查找时根据这个对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。</p><h1 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h1><p>构造哈希函数的方法有很多，首先需要明确什么是“好”的哈希函数？<br>若相对于关键字集合中的人一个键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称为此类哈希函数为<strong>均匀</strong>的哈希函数。换句话说，就是使关键字经过哈希函数得到一个随机的地址，一遍使一组关键字的哈希地址均匀分布在整个地址取件中，从而减小冲突。</p><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>取关键字或关键字的某个线性函数值为散列地址。即<br>H(key)=key或H(key) = a·key + b，<br>其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。</p><h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址</p><h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加</p><h3 id="保留余数法"><a href="#保留余数法" class="headerlink" title="保留余数法"></a>保留余数法</h3><p>选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。</p><h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key)，其中random为随机函数，通常，当关键字不等时采用此法构造哈希函数较恰当。</p><p>实际工作中虚视不同的情况采用不同的哈希函数，通常考虑因素有：</p><ol><li>计算哈希函数所需时间；</li><li>关键字的长度；</li><li>哈希表的打消；</li><li>关键字的分布情况；</li><li>记录的查找频率；</li></ol><h1 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h1><h3 id="开发寻址法"><a href="#开发寻址法" class="headerlink" title="开发寻址法"></a>开发寻址法</h3><p>Hi=(H(key) + di) MOD m,i=1,2，…，k(k&lt;=m-1）<br>其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：</p><ul><li>di=1,2,3，…，m-1，称线性探测再散列；</li><li>di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次探测再散列；</li><li>di=伪随机数序列，称伪随机探测再散列。<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3>Hi=RHi(key),i=1,2，…，k<br>RHi均是不同的哈希函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3>将所有关键字为同义词的记录存储在同一线性表中。<h3 id="建立一个公共溢出区"><a href="#建立一个公共溢出区" class="headerlink" title="建立一个公共溢出区"></a>建立一个公共溢出区</h3>假设哈希函数的值域为[0, m - 1]，则设向量HashTable[0..m - 1]为基本表，每个分量存放一个记录，另设向量OverTable[o..v]为溢出表，所有关键字和基本表中关键字为同义词的记录，不管他们有哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-线索二叉树</title>
      <link href="/posts/4035dbb/"/>
      <url>/posts/4035dbb/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列、后序序列、这实质上是对一个非线性结构进行线性化的操作，使每个结点在这些线性序列中有且仅有一个直接前驱和直接后继。<br>但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接找到结点在任一序列中的前驱和后继的信息。<br>如何保存这种在遍历过程中得到的信息呢？对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为<strong>线索</strong>，加上线索的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程称为<strong>线索化</strong>。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li>结点左子树为空，利用左孩子的指针指向前驱结点；</li><li>结点右子树为空，利用右孩子的指针指向后继结点；</li><li>所有的前驱、后继按照某一个遍历逻辑；</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大结点数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">TElemType Nil = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark--二叉树构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> indexs = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">String</span>[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">String</span> str;</span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(<span class="keyword">String</span> T,<span class="keyword">char</span> *chars)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(chars) &gt; <span class="number">100</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    T[<span class="number">0</span>] = <span class="built_in">strlen</span>(chars);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">        T[i] =* (chars + i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Thread BiTree</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</span><br><span class="line">    Link,</span><br><span class="line">    Thread</span><br><span class="line">} PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> {</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    PointerTag LTag, RTag;</span><br><span class="line">} BiThrNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(TElemType e)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>,e);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiThrTree</span><span class="params">(BiThrTree *T)</span> </span>{</span><br><span class="line">    TElemType e = str[indexs++];</span><br><span class="line">    <span class="keyword">if</span> (e == Nil) {</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        *T = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        (*T)-&gt;data = e;</span><br><span class="line">        CreateBiThrTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> ((*T)-&gt;lchild) {</span><br><span class="line">            (*T)-&gt;LTag = Link;</span><br><span class="line">        }</span><br><span class="line">        CreateBiThrTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span> ((*T)-&gt;rchild) {</span><br><span class="line">            (*T)-&gt;RTag = Link;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BiThrTree pre;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p) {</span><br><span class="line">        InThreading(p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild) {</span><br><span class="line">            p-&gt;LTag = Thread;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p-&gt;LTag = Link;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild) {</span><br><span class="line">            pre-&gt;RTag = Thread;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pre-&gt;RTag = Link;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderThreading</span><span class="params">(BiThrTree *Thrt , BiThrTree T)</span> </span>{</span><br><span class="line">    *Thrt = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line">    <span class="keyword">if</span> (*Thrt == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    (*Thrt)-&gt;LTag = Link;</span><br><span class="line">    (*Thrt)-&gt;RTag = Thread;</span><br><span class="line">    (*Thrt)-&gt;rchild = (*Thrt);</span><br><span class="line">    <span class="keyword">if</span> (!T) {</span><br><span class="line">        (*Thrt)-&gt;lchild = *(Thrt);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        (*Thrt)-&gt;lchild = T;</span><br><span class="line">        pre = (*Thrt);</span><br><span class="line">        </span><br><span class="line">        InThreading(T);</span><br><span class="line">        </span><br><span class="line">        pre-&gt;rchild = *Thrt;</span><br><span class="line">        pre-&gt;RTag = Thread;</span><br><span class="line">        </span><br><span class="line">        (*Thrt)-&gt;rchild = pre;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> </span>{</span><br><span class="line">    BiThrTree p;</span><br><span class="line">    p = T-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (p != T) {</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;LTag == Link) {</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T) {</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            visit(p-&gt;data);</span><br><span class="line">        }</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-查找</title>
      <link href="/posts/24abe8e7/"/>
      <url>/posts/24abe8e7/</url>
      
        <content type="html"><![CDATA[<p><strong>查找表</strong>是由同一类型的数据元素构成的集合。由于集合中的数据元素之间存在着完全松散的换洗，因此查找表是一种非常领边的数据结构。</p><p>对查找表经常进行的操作：</p><ul><li>查询某个特定的数据元素是否在查找表中；</li><li>检索某个特定的数据元素的各种属性；</li><li>在查找表中插入一个数据元素；</li><li>在查找表中删去某个数据元素；</li></ul><h1 id="静态查找表（Static-search-table）"><a href="#静态查找表（Static-search-table）" class="headerlink" title="静态查找表（Static search table）"></a>静态查找表（Static search table）</h1><h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><p><strong>顺序查找</strong>（Sequential Search）的查找过程：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若知道第一个记录，其关键字和给定值比较不相等，则表明表中没有所查记录，查找不成功。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; I &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search_Guard</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = n;</span><br><span class="line">    a[<span class="number">0</span>] = key;</span><br><span class="line">    <span class="keyword">while</span> (a[i] != key) {</span><br><span class="line">        i--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h4><p><strong>折半查找</strong>（Binary Search）的查找过程：先确定待查找记录所在的范围，然后珠逐步缩小范围直到找到或找不到该记录为止。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        mid = (high + low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) {</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]) {</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Interpolation_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]);</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) {</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid]) {</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.斐波拉契查找</span></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">100</span>]; <span class="comment">/* 斐波那契数列 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> low, high, mid, i, k;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = n;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; F[k] - <span class="number">1</span>) {</span><br><span class="line">        k++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i = n; i &lt; F[k] - <span class="number">1</span>; i++)</span><br><span class="line">        a[i] = a[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        mid = low + F[k<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) {</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k = k - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid]){</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k = k - <span class="number">2</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= n) {</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="动态查找表-（Dynamic-search-table）"><a href="#动态查找表-（Dynamic-search-table）" class="headerlink" title="动态查找表 （Dynamic search table）"></a>动态查找表 （Dynamic search table）</h1><p><strong>二叉排序树</strong>（Binary sort Tree）或者是一颗空树；或者是具有下列性质的二叉树；</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的跟结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的跟结点的值；</li><li>它的左、右子树也分别为二叉树排序树；<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">} BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉排序树--查找</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!T) {</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == key) {</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data) {</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    BiTree p, s;</span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) {</span><br><span class="line">        s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!p) {</span><br><span class="line">            *T = s;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data) {</span><br><span class="line">            p-&gt;lchild = s;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p-&gt;rchild = s;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二叉排序树中删除结点p,并重接它的左或者右子树;</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span></span>{</span><br><span class="line">    BiTree temp, s;</span><br><span class="line">    <span class="keyword">if</span>((*p)-&gt;rchild == <span class="literal">NULL</span>) {</span><br><span class="line">        temp = *p;</span><br><span class="line">        *p = (*p)-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild == <span class="literal">NULL</span>) {</span><br><span class="line">        temp = *p;</span><br><span class="line">        *p = (*p)-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        temp = *p;</span><br><span class="line">        s = (*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rchild) {</span><br><span class="line">            temp = s;</span><br><span class="line">            s = s-&gt;rchild;</span><br><span class="line">        }</span><br><span class="line">        (*p)-&gt;data = s-&gt;data;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(temp != *p)</span><br><span class="line">            temp-&gt;rchild = s-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp-&gt;lchild = s-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找结点,并将其在二叉排序中删除;</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(!*T) {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (key == (*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; (*T)-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild, key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-拓扑排序 &amp; 关键路径</title>
      <link href="/posts/b47980b9/"/>
      <url>/posts/b47980b9/</url>
      
        <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序的序列，简称<strong>拓扑序列</strong>。简单的说，由某个集合上的一个偏序得到集合上的一个全序，这个操作称之为<strong>拓扑排序</strong>。<br>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样有向图为顶点表示活动的网，我们称为<strong>AOV网</strong>。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>从AOV网中选择⼀个入度为0的顶点输出</li><li>然后删去此顶点,并删除以此顶点为尾的弧. </li><li>继续重复此步骤,直到输出全部顶点或AOV网中不存在入度为0的顶点为⽌.</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MGraph</span> {</span></span><br><span class="line">    <span class="keyword">int</span> vexs[MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> numVertexes, numEdges;</span><br><span class="line">} MGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> in;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    EdgeNode *firstedge;</span><br><span class="line">} VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="keyword">int</span> numVertexes, numEdges;</span><br><span class="line">} graphAdjList, *GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * GL-&gt;numVertexes);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++) {</span><br><span class="line">        <span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="keyword">int</span> getTop, k;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">0</span>) {</span><br><span class="line">        getTop = <span class="built_in">stack</span>[top--];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, GL-&gt;adjList[getTop].data);</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (e = GL-&gt;adjList[getTop].firstedge; e; e = e-&gt;next) {</span><br><span class="line">            k = e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (--GL-&gt;adjList[k].in == <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">stack</span>[++top] = k;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &lt; GL-&gt;numVertexes) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表表示活动的网,我们称之为<strong>AOE 网</strong>(Activity On Edge Network)<br>没有入边的顶点称为始点或源点；<br>没有出边的顶点称为终点或汇点；<br>由于一个⼯程，总有一个开始，一个结束。所以正常情况下，AOE⽹网只有一个源点和一个汇点。</p><ul><li>路径上各个活动所持续的时间之和称为路径长度</li><li>从源点到汇点具有最大的路径叫关键路径</li><li>在关键路径上的活动叫关键活动</li></ul><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><ul><li>事件最早发生的时间<strong>etv</strong>(earliest time of vertex): 即顶点Vk的最早发生时间；</li><li>事件最晚发生时间<strong>ltv</strong>(latest time fo vertex):即顶点Vk的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期；</li><li>活动的最早开工时间<strong>ete</strong>(earliest time of edge): 即弧Ak的最早发生时间；</li><li>活动的最晚开工时间<strong>lte</strong>(latest time of edge): 即弧Ak的最晚发生时间，也就是不推迟工期的最晚开工时间；</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *etv, *ltv; <span class="comment">// 事件最早发生时间和最迟发生时间数组，全局变量</span></span><br><span class="line"><span class="keyword">int</span> *stack2;    <span class="comment">// 用于存储拓扑序列的栈</span></span><br><span class="line"><span class="keyword">int</span> top2;       <span class="comment">// 用于stack2的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * GL-&gt;numVertexes);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++) {</span><br><span class="line">        <span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    top2 = <span class="number">0</span>;</span><br><span class="line">    stack2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * GL-&gt;numVertexes);</span><br><span class="line">    etv = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * GL-&gt;numVertexes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++) {</span><br><span class="line">        etv[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="keyword">int</span> getTop, k;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">0</span>) {</span><br><span class="line">        getTop = <span class="built_in">stack</span>[top--];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, GL-&gt;adjList[getTop].data);</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        stack2[++top2] = getTop;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (e = GL-&gt;adjList[getTop].firstedge; e; e = e-&gt;next) {</span><br><span class="line">            k = e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (--GL-&gt;adjList[k].in == <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">stack</span>[++top] = k;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (etv[getTop] + e-&gt;weight &gt; etv[k]) {</span><br><span class="line">                etv[k] = etv[getTop] + e-&gt;weight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &lt; GL-&gt;numVertexes) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(GraphAdjList GL)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, k, getTop;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    </span><br><span class="line">    TopologicalSort(GL);</span><br><span class="line">    </span><br><span class="line">    ltv = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * GL-&gt;numVertexes);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; i++) {</span><br><span class="line">        ltv[i] = etv[GL-&gt;numVertexes - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (top2 != <span class="number">0</span>) {</span><br><span class="line">        getTop = stack2[top2--];</span><br><span class="line">        <span class="keyword">for</span> (e = GL-&gt;adjList[getTop].firstedge; e; e = e-&gt;next) {</span><br><span class="line">            k = e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (ltv[k] - e-&gt;weight &lt; ltv[getTop]) {</span><br><span class="line">                ltv[getTop] = ltv[k] - e-&gt;weight;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ete,lte;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; GL-&gt;numVertexes; j++) {</span><br><span class="line">        <span class="keyword">for</span> (e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next) {</span><br><span class="line">            k = e-&gt;adjvex;</span><br><span class="line">            ete = etv[j];</span><br><span class="line">            lte = ltv[k] - e-&gt;weight;</span><br><span class="line">            <span class="keyword">if</span> (ete == lte) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"&lt;%d-%d&gt; length:%d\n"</span>, GL-&gt;adjList[j].data, GL-&gt;adjList[k].data, e-&gt;weight);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表中删除相等的多余结点</title>
      <link href="/posts/195c875e/"/>
      <url>/posts/195c875e/</url>
      
        <content type="html"><![CDATA[<p>最短路径问题是<strong>图</strong>研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：</p><ul><li><p>确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。</p></li><li><p>确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</p></li><li><p>确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。</p></li><li><p>全局最短路径问题 - 求图中所有的最短路径。</p></li></ul><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>Dijkstra提出了一个按路径长度递增的次序产生最短路径的算法。<br>首先，我们引入一个辅助向量D，它的每个分量D[i]表示当前找到的从起始节点v到终点节点vi的最短路径的长度。它的初始态为：若从节点v到节点vi有弧，则D[i]为弧上的权值，否则D[i]为∞，显然，长度为<br><strong>D[j] = Min{D[i] | vi ∈V}</strong><br>的路径就是从v出发最短的一条路径，路径为(v, vi)。<br>那么，下一条长度次短的最短路径是哪一条呢？假设次短路径的终点是vk，则可想而知，这条路径或者是(v, vk)或者是(v, vj, vk)。它的长度或者是从v到vk的弧上的权值，或者是D[j]和从vj到vk的权值之和。</p><p>一般情况下，假设S为已知求得的最短路径的终点集合，则可证明：一下条最短路径（设其终点为x）或者是弧(v, x)或者是中间只经过S中的顶点而最后到达顶点x的路径。这可用反证法来证明，假设此路径上有一个顶点不在S中，则说明存在一条终点不在S中而长度比此路径短的路径。但是这是不可能的。因为，我们是按路径常度的递增次序来产生个最短路径的，故长度比此路径端的所有路径均已产生，他们的终点必定在S集合中，即假设不成立。</p><p>因此下一条次短的最短路径的长度是：<br><strong>D[j] = Min{D[i] | vi ∈ V - S}</strong><br>其中，D[i]或者是弧(v, vi)的权值，或者是D[k](vk ∈ S)和弧(vk, vi)上权值之和。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 最短路径 - Dijkstra 算法</span></span><br><span class="line"><span class="comment">/// @param G 网图</span></span><br><span class="line"><span class="comment">/// @param v0 开始的顶点</span></span><br><span class="line"><span class="comment">/// @param P 前驱顶点下标</span></span><br><span class="line"><span class="comment">/// @param D 表示从V0到V的最短路径长度和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstra</span><span class="params">(MGraph G, <span class="keyword">int</span> v0, Patharc *P, ShortPathTable *D)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> v, w, k, <span class="built_in">min</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">final</span>[MAXVEX];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++) {</span><br><span class="line">        <span class="keyword">final</span>[v] = <span class="number">0</span>;</span><br><span class="line">        (*D)[v] = G.arc[v0][v];</span><br><span class="line">        (*P)[v] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span>[v0] = <span class="number">1</span>;</span><br><span class="line">    (*D)[v0] = <span class="number">0</span>;</span><br><span class="line">    (*P)[v0] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.numVertexes; v++) {</span><br><span class="line">        <span class="built_in">min</span> = INFINITYC;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; w++) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (*D)[w] &lt; <span class="built_in">min</span>) {</span><br><span class="line">                k = w;</span><br><span class="line">                <span class="built_in">min</span> = (*D)[w];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span>[k] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; w++) {</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; <span class="built_in">min</span> + G.arc[k][w] &lt; (*D)[w]) {</span><br><span class="line">                (*D)[w] = <span class="built_in">min</span> + G.arc[k][w];</span><br><span class="line">                (*P)[w] = k;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph G, Patharc *P, ShortPathTable *D)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> v, w, k;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++) {</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; w++) {</span><br><span class="line">            (*D)[v][w] = G.arc[v][w];</span><br><span class="line">            (*P)[v][w] = w;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.numVertexes; k++) {</span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++) {</span><br><span class="line">            <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; w++) {</span><br><span class="line">                <span class="keyword">if</span> ((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w]) {</span><br><span class="line">                    (*D)[v][w] = (*D)[v][k] + (*D)[k][w];</span><br><span class="line">                    (*P)[v][w] = (*P)[v][k];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-最小生成树</title>
      <link href="/posts/d4f49403/"/>
      <url>/posts/d4f49403/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>连通图的生成树</strong>是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一颗树的n-1条边。</p><p>构造连通网的最小代价生成树简称为<strong>最小生成树</strong>。</p><h1 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>定义2个数组，adjvex 用来保存相关顶点下标，lowcost 保存顶点之间的权值</li><li>初始化2个数组, 从v0开始寻找最小⽣成树, 默认v0是最小生成树上第一个顶点 </li><li>循环lowcost 数组,根据权值,找到顶点 k;</li><li>更新lowcost 数组</li><li>循环所有顶点,找到与顶点k 有关系的顶点. 并更新lowcost 数组与adjvex 数组;</li></ol><blockquote><p>注意更新lowcost 数组与adjvex 数组的条件:</p><ol><li>与顶点k 之间有连接</li><li>当前结点 j 没有加入过最小生成树;</li><li>顶点 k 与 当前顶点 j 之间的权值 小于 顶点j 与其他顶点 k 之前的权值. 则更新. 简单说就是要比较之前存储的值要小,则更新;</li></ol></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Prim算法生成最小生成树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph G)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>, i, j, k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> adjvex[MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> lowcost[MAXVEX];</span><br><span class="line">    </span><br><span class="line">    lowcost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    adjvex[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.numVertexes; i++) {</span><br><span class="line">        lowcost[i] = G.arc[<span class="number">0</span>][i];</span><br><span class="line">        adjvex[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.numVertexes; i++) {</span><br><span class="line">        <span class="built_in">min</span> = INFINITYC;</span><br><span class="line">        </span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; G.numVertexes; j++) {</span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; <span class="built_in">min</span>) {</span><br><span class="line">                <span class="built_in">min</span> = lowcost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(V%d, V%d) = %d\n"</span>, adjvex[k], k , G.arc[adjvex[k]][k]);</span><br><span class="line">        sum += G.arc[adjvex[k]][k];</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; G.numVertexes; j++) {</span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j]) {</span><br><span class="line">                lowcost[j] = G.arc[k][j];</span><br><span class="line">                adjvex[j] = k;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>, sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ol><li>将邻接矩阵转化成边表数组；</li><li>对边表数组根据权值按照从小到大的顺序排序；</li><li>遍历所有的边， 通过parent 数组找到边的连接信息，避免闭环问题；</li><li>如果不存在闭环问题,则加入到最小生成树中，并且修改parent 数组；<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">} Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Prim算法生成最小生成树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swapn</span><span class="params">(Edge *edges, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = edges[i].<span class="built_in">begin</span>;</span><br><span class="line">    edges[i].<span class="built_in">begin</span> = edges[j].<span class="built_in">begin</span>;</span><br><span class="line">    edges[j].<span class="built_in">begin</span> = temp;</span><br><span class="line">    </span><br><span class="line">    temp = edges[i].<span class="built_in">end</span>;</span><br><span class="line">    edges[i].<span class="built_in">end</span> = edges[j].<span class="built_in">end</span>;</span><br><span class="line">    edges[j].<span class="built_in">end</span> = temp;</span><br><span class="line">    </span><br><span class="line">    temp = edges[i].weight;</span><br><span class="line">    edges[i].weight = edges[j].weight;</span><br><span class="line">    edges[j].weight = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">(Edge edges[], MGraph *G)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numEdges; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; G-&gt;numEdges; j++) {</span><br><span class="line">            <span class="keyword">if</span> (edges[i].weight &gt; edges[j].weight) {</span><br><span class="line">                Swapn(edges, i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> f)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (parent[f] &gt; <span class="number">0</span>) {</span><br><span class="line">        f = parent[f];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(MGraph G)</span>  </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j, n, m;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Edge edges[MAXVEX];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numVertexes; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; G.numVertexes; j++) {</span><br><span class="line">            <span class="keyword">if</span> (G.arc[i][j] &lt; INFINITYC) {</span><br><span class="line">                edges[k].<span class="built_in">begin</span> = i;</span><br><span class="line">                edges[k].<span class="built_in">end</span> = j;</span><br><span class="line">                edges[k].weight = G.arc[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    Sort(edges, &amp;G);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> parent[MAXVEX] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.numEdges; i++) {</span><br><span class="line">        m = Find(parent, edges[i].<span class="built_in">begin</span>);</span><br><span class="line">        n = Find(parent, edges[i].<span class="built_in">end</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m != n) {</span><br><span class="line">            parent[m] = n;</span><br><span class="line">            sum += edges[i].weight;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"(%d, %d) %d\n"</span>, edges[i].<span class="built_in">begin</span>, edges[i].<span class="built_in">end</span>, edges[i].weight);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>, sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法--图</title>
      <link href="/posts/287e070f/"/>
      <url>/posts/287e070f/</url>
      
        <content type="html"><![CDATA[<p><strong>图</strong>（Graph）是一种较线性表和树更复杂的数据结构。在图形结构中，结点之间的关系可以是任一的，图中任意两个数据元素之间都可能相关。</p><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中V={v1,v2,…,vn}  。G的邻接矩阵是一个具有下列性质的n阶方阵：</p><ul><li>对无向图而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，有向图则不一定如此。</li><li>在无向图中，任一顶点i的度为第i列（或第i行）所有非零元素的个数，在有向图中顶点i的出度为第i行所有非零元素的个数，而入度为第i列所有非零元素的个数。</li><li>用邻接矩阵法表示图共需要n^2个空间，由于无向图的邻接矩阵一定具有对称关系，所以扣除对角线为零外，仅需要存储上三角形或下三角形的数据即可，因此仅需要n（n-1）/2个空间。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITYC 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MGraph</span> {</span></span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];</span><br><span class="line">    EdgeType arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="keyword">int</span> numNodes, numEdges;</span><br><span class="line">} MGraph;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMGraph</span><span class="params">(MGraph *G)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入顶点数和边数:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>, &amp;G-&gt;numNodes, &amp;G-&gt;numEdges);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"顶点数:%d,边数:%d\n"</span>, G-&gt;numNodes, G-&gt;numEdges);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i, j, w;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numNodes; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;G-&gt;vexs[i]);</span><br><span class="line">        getchar();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numNodes; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;numNodes; i++) {</span><br><span class="line">            G-&gt;arc[i][j] = INFINITYC;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numEdges; k++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入边(vi, vj)上的下标i, 下标j, 权w\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d,%d,%d"</span>, &amp;i, &amp;j, &amp;w);</span><br><span class="line">        G-&gt;arc[i][j] = w;</span><br><span class="line">        G-&gt;arc[j][i] = G-&gt;arc[i][j];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numNodes; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;numNodes; j++) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,G-&gt;arc[i][j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><strong>邻接表</strong>（Adjacency List）是图的一种链式存储结构。在连接表中，对图中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点v1的边。每个结点由3个域组成，其中邻接点域（adjvex）指示与顶点v1邻接的点在图中的位置，链域（nextarc）指示下一条边或弧的结点。数据域存储和边或弧相关的信息。每个链表附设一个表头结点。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Element;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    Element data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextArc</span>;</span></span><br><span class="line">} ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> {</span></span><br><span class="line">    Element data;</span><br><span class="line">    ArcNode * firstedge;</span><br><span class="line">} VertexNode, Adjlist[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> {</span></span><br><span class="line">    Adjlist adjlist;</span><br><span class="line">    <span class="keyword">int</span> arc_num;</span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    BOOL is_directed;</span><br><span class="line">} ALGraph, *GraphLink;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(GraphLink *G)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入顶点数目, 边数和方向？：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;(*G)-&gt;node_num, &amp;(*G)-&gt;arc_num, &amp;(*G)-&gt;is_directed);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入顶点信息：\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (*G)-&gt;node_num; i++) {</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;(*G)-&gt;adjlist[i].data);</span><br><span class="line">        (*G)-&gt;adjlist[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入边信息：\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (*G)-&gt;arc_num; k++) {</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;i, &amp;j);</span><br><span class="line">        </span><br><span class="line">        p = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">        p-&gt;adjvex = j;</span><br><span class="line">        p-&gt;nextArc = (*G)-&gt;adjlist[i].firstedge;</span><br><span class="line">        (*G)-&gt;adjlist[i].firstedge = p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(*G)-&gt;is_directed) {</span><br><span class="line">            p = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">            p-&gt;adjvex = i;</span><br><span class="line">            p-&gt;nextArc = (*G)-&gt;adjlist[j].firstedge;</span><br><span class="line">            (*G)-&gt;adjlist[j].firstedge = p;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putGraph</span><span class="params">(GraphLink G)</span></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"邻接表中存储信息:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;node_num; i++) {</span><br><span class="line">        ArcNode *p = G-&gt;adjlist[i].firstedge;</span><br><span class="line">        <span class="keyword">while</span> (p) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c "</span>, G-&gt;adjlist[i].data, G-&gt;adjlist[p-&gt;adjvex].data);</span><br><span class="line">            p = p-&gt;nextArc;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    GraphLink g = (ALGraph *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ALGraph));</span><br><span class="line">    CreateGraph(&amp;g);</span><br><span class="line">    putGraph(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>和树的遍历类似，从图中某一个顶点出发访遍图中其余顶点，且使每一个顶点紧被访问一次，这一过程叫<strong>图的遍历</strong>。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h4 id="邻接矩阵深度优先搜索"><a href="#邻接矩阵深度优先搜索" class="headerlink" title="邻接矩阵深度优先搜索"></a>邻接矩阵深度优先搜索</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 邻接矩阵深度优先搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Boolean visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, G.vexs[v]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; G.arc[v][i] == <span class="number">1</span>) {</span><br><span class="line">            DFS(G, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++) {</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) {</span><br><span class="line">            DFS(G, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="邻接表深度优先搜索"><a href="#邻接表深度优先搜索" class="headerlink" title="邻接表深度优先搜索"></a>邻接表深度优先搜索</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 邻接表深度优先搜索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">BOOL visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph G, <span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, G.adjlist[v].data);</span><br><span class="line">    </span><br><span class="line">    ArcNode *p;</span><br><span class="line">    p = G.adjlist[v].firstedge;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[p-&gt;adjvex]) {</span><br><span class="line">            DFS(G, p-&gt;adjvex);</span><br><span class="line">        }</span><br><span class="line">        p = p-&gt;nextArc;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(ALGraph G)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.node_num; i++) {</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.node_num; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) {</span><br><span class="line">            DFS(G, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>分析上述算法，在遍历图时，对图中每个顶点至多调用一次DFS函数，因为一旦某个顶点被标志成已被访问，就不再从它出发进行搜索。因此，遍历图的过程实质上是对每个顶点查找其邻接点的过程。其耗费的时间则取决于所采用的存储结构。</p><ul><li>当用二维数组表示邻接矩阵图的存储结构时，查找每个顶点的邻接点所需要的时间为O(n^2),其中n为图中顶点数。</li><li>当用邻接表作图的存储结构时，找邻接点所需要的时间为O(e)，其中e为无向图中边的数或有向图中弧的数，因此，当以邻接表作为存储结构时，深度优化搜索遍历图的时间浮渣度为O(n + e)。</li></ul></blockquote><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h4 id="邻接矩阵的广度优先搜索"><a href="#邻接矩阵的广度优先搜索" class="headerlink" title="邻接矩阵的广度优先搜索"></a>邻接矩阵的广度优先搜索</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邻接矩阵广度优先搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++) {</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) {</span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, G.vexs[i]);</span><br><span class="line">            </span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q)) {</span><br><span class="line">                DeQueue(&amp;Q, &amp;i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.numNodes; j++) {</span><br><span class="line">                    <span class="keyword">if</span> (G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) {</span><br><span class="line">                        visited[j] = TRUE;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c "</span>, G.vexs[j]);</span><br><span class="line">                        EnQueue(&amp;Q, j);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="邻接表的广度优先搜索"><a href="#邻接表的广度优先搜索" class="headerlink" title="邻接表的广度优先搜索"></a>邻接表的广度优先搜索</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">邻接表广度优先搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(ALGraph G)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.node_num; i++) {</span><br><span class="line">        visited[i] = FALSE;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.node_num; i++) {</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) {</span><br><span class="line">            visited[i] = TRUE;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, G.adjlist[i].data);</span><br><span class="line">            </span><br><span class="line">            EnQueue(&amp;Q, i);</span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q)) {</span><br><span class="line">                DeQueue(&amp;Q, &amp;i);</span><br><span class="line">                p = G.adjlist[i].firstedge;</span><br><span class="line">                <span class="keyword">while</span> (p) {</span><br><span class="line">                    <span class="keyword">if</span> (!visited[p-&gt;adjvex]) {</span><br><span class="line">                        visited[p-&gt;adjvex] = TRUE;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c "</span>, G.adjlist[p-&gt;adjvex].data);</span><br><span class="line">                        EnQueue(&amp;Q, p-&gt;adjvex);</span><br><span class="line">                    }</span><br><span class="line">                    p = p-&gt;nextArc;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>分析上述算法，每个顶点至多进一次队列。遍历图的过程实质上是通过边和弧找邻接点的过程。因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，两者不同之处仅仅在于对顶点访问的顺序不同。</p></blockquote><hr><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础-哈夫曼树</title>
      <link href="/posts/55942c7b/"/>
      <url>/posts/55942c7b/</url>
      
        <content type="html"><![CDATA[<p>假设有n个权值{w1, w2, …, wn}，试构造一颗有n个叶子结点的二叉树，每个叶子结点带权为wi，则其中带权路径长度WPL最小的二叉树称做<strong>最优二叉树</strong>或<strong>赫夫曼树</strong>。</p><h1 id="构造赫夫曼树"><a href="#构造赫夫曼树" class="headerlink" title="构造赫夫曼树"></a>构造赫夫曼树</h1><p>赫夫曼算法：</p><ol><li>根据给定的n个权值{w1, w2, …, wn}构成N棵二叉树的集合F = {T1, T2,… , Tn}，其中每棵而茶水Ti中只有一个带权为wi的跟结点，其左右子树均空。</li><li>在F中选取两颗跟结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的跟结点的权值为其左、右树上跟结点的权值之和。</li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>重复（2）（3），直到F只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxValue = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxBit = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HaffNode</span> {</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> leftChild;</span><br><span class="line">    <span class="keyword">int</span> rightChild;</span><br><span class="line">} HaffNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Haffman</span><span class="params">(<span class="keyword">int</span> weight[], <span class="keyword">int</span> n, HaffNode *haffTree)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) {</span><br><span class="line">            haffTree[i].weight = weight[i];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            haffTree[i].weight = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        haffTree[i].flag = <span class="number">0</span>;</span><br><span class="line">        haffTree[i].parent = <span class="number">0</span>;</span><br><span class="line">        haffTree[i].leftChild = <span class="number">-1</span>;</span><br><span class="line">        haffTree[i].rightChild = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j, m1, m2, x1, x2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">        m2 = m1 = MaxValue;</span><br><span class="line">        x2 = x1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n + i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (haffTree[j].weight &lt; m1 &amp;&amp; haffTree[j].flag == <span class="number">0</span>) {</span><br><span class="line">                m2 = m1 = haffTree[j].weight;</span><br><span class="line">                x2 = x1 = j;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (haffTree[j].weight &lt; m2 &amp;&amp; haffTree[j].flag == <span class="number">0</span>) {</span><br><span class="line">                m2 = haffTree[j].weight;</span><br><span class="line">                x2 = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        haffTree[x1].parent = n + i;</span><br><span class="line">        haffTree[x1].flag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        haffTree[x2].parent = n + i;</span><br><span class="line">        haffTree[x2].flag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        haffTree[n + i].weight = haffTree[x1].weight + haffTree[x2].weight;</span><br><span class="line">        haffTree[n + i].leftChild = x1;</span><br><span class="line">        haffTree[n + i].rightChild = x2;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h1><p>哈夫曼编码是一种编码方式，该方法依据字符出现概率来构造异字头的平均长度最短的码字，一般就叫做Huffman编码。</p><p>哈夫曼思想就是依据使用的频率来最大化的节省字符存储空间。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Code</span> {</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">bit</span>[MaxBit];</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">} Code;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HaffmanCode</span><span class="params">(HaffNode haffTree[], <span class="keyword">int</span> n, Code haffCode[])</span> </span>{</span><br><span class="line">    Code *cd = (Code *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Code));</span><br><span class="line">    <span class="keyword">int</span> child, parent;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cd-&gt;start = <span class="number">0</span>;</span><br><span class="line">        cd-&gt;weight = haffTree[i].weight;</span><br><span class="line">        child = i;</span><br><span class="line">        parent = haffTree[child].parent;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (haffTree[parent].leftChild == child) {</span><br><span class="line">                cd-&gt;<span class="built_in">bit</span>[cd-&gt;start] = <span class="number">0</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cd-&gt;<span class="built_in">bit</span>[cd-&gt;start] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            cd-&gt;start++;</span><br><span class="line">            child = parent;</span><br><span class="line">            parent = haffTree[child].parent;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = cd-&gt;start - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">            temp = cd-&gt;start - <span class="number">1</span> - j;</span><br><span class="line">            haffCode[i].<span class="built_in">bit</span>[temp] = cd-&gt;<span class="built_in">bit</span>[j];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        haffCode[i].start = cd-&gt;start;</span><br><span class="line">        haffCode[i].weight = cd-&gt;weight;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-二叉树</title>
      <link href="/posts/a142d053/"/>
      <url>/posts/a142d053/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>二叉树，是每个节点最多只有两个分之的树结构，通常分之被称作“左子树”或者“右子树”；二叉树的分之具有左右次序，且不能随意颠倒。</p><ul><li><strong>满二叉树</strong>：一棵深度为k，且有2^k-1 个结点的二叉树；</li><li><strong>完全二叉树</strong>：在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点；</li><li><strong>左斜树：</strong>所有节点都只有左子树</li><li><strong>右斜树：</strong>所有节点都只有右子树<h1 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h1></li></ul><ol><li>在二叉树的第i层上最多有2^(i-1)个结点；</li><li>深度为k的二叉树最多有2k-1个节点(k&gt;=1)；</li><li>对于任何一颗二叉树T，如果其终端节点树为n0，度为2的节点书数为n2，则n0 = n2 + 1；</li><li>具有n个节点的完全二叉树深度为(log2(n)) + 1；</li><li>对具有n个节点的完全二叉树，如果按照从上到下和从左到右的顺序对二叉树的所有节点从1开始编号，则对于任意的序号为i的结点有：<ul><li>如果i &gt; 1，那么序号为i的节点的双亲结点为i/2;</li><li>如果i = 1，那么序号为i的结点为根结点，无双亲节点；</li><li>如果2i &lt;=n，那么序号为i的结点的左孩子结点序号为2i；</li><li>如果2i &gt; n；那么序号为i的结点无左孩子；</li><li>如果2i + i &lt;= n；那么序号为i的结点右孩子序号为2i + 1；</li><li>如果2i + i &gt; n；那么序号为i的结点无左孩子。<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大结点数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> CElemType;</span><br><span class="line"><span class="keyword">typedef</span> CElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">CElemType Nil = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> order;</span><br><span class="line">} Position;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mrak - 二叉树的基本操作</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TREE_SIZE; i++) {</span><br><span class="line">        T[i] = Nil;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line">        T[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; T[(i + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>] == Nil &amp;&amp; T[i] != Nil) {</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; MAX_TREE_SIZE) {</span><br><span class="line">        T[i++] = Nil;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClearBiTree InitBiTree</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> T[<span class="number">0</span>] == Nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeDepth</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = MAX_TREE_SIZE - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (T[i] != Nil) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        j++;</span><br><span class="line">    } <span class="keyword">while</span> (<span class="built_in">pow</span>(<span class="number">2</span>, j) &lt; i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">Value</span><span class="params">(SqBiTree T, Position e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> T[(<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, e.level - <span class="number">1</span>) + e.order - <span class="number">2</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Root</span><span class="params">(SqBiTree T,CElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (BiTreeEmpty(T)) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    *e = T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Assign</span><span class="params">(SqBiTree T, Position e, CElemType value)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, e.level <span class="number">-1</span> ) + e.order - <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//叶子结点的双亲为空</span></span><br><span class="line">    <span class="keyword">if</span> (value != Nil &amp;&amp; T[(i + <span class="number">1</span>) / <span class="number">2</span> <span class="number">-1</span>] == Nil) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给双亲赋空值但是有叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (value == Nil &amp;&amp; (T[i * <span class="number">2</span> + <span class="number">1</span>] != Nil || T[i * <span class="number">2</span> + <span class="number">2</span>] != Nil)) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    T[i] = value;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">Parent</span><span class="params">(SqBiTree T, CElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_TREE_SIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (T[i] == e) {</span><br><span class="line">            <span class="keyword">return</span> T[(i + <span class="number">1</span>) / <span class="number">2</span> <span class="number">-1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">LeftChild</span><span class="params">(SqBiTree T, CElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TREE_SIZE - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (T[i] == e) {</span><br><span class="line">            <span class="keyword">return</span> T[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">RightChild</span><span class="params">(SqBiTree T, CElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TREE_SIZE - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (T[i] == e) {</span><br><span class="line">            <span class="keyword">return</span> T[i * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">LeftSibling</span><span class="params">(SqBiTree T,CElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_TREE_SIZE - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (T[i] == e &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> T[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">RightSibling</span><span class="params">(SqBiTree T,CElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">0</span>] == Nil) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_TREE_SIZE - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (T[i] == e &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> T[i + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Nil;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(CElemType c)</span></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,c);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = MAX_TREE_SIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T[i] != Nil) {</span><br><span class="line">        i--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">        <span class="keyword">if</span> (T[j] != Nil) {</span><br><span class="line">            visit(T[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(SqBiTree T, <span class="keyword">int</span> e)</span> </span>{</span><br><span class="line">    visit(T[e]);</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">1</span>] != Nil) {</span><br><span class="line">        PreTraverse(T, <span class="number">2</span> * e + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">2</span>] != Nil) {</span><br><span class="line">        PreTraverse(T, <span class="number">2</span> * e + <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!BiTreeEmpty(T)) {</span><br><span class="line">        PreTraverse(T, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InTraverse</span><span class="params">(SqBiTree T, <span class="keyword">int</span> e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">1</span>] != Nil) {</span><br><span class="line">        InTraverse(T, <span class="number">2</span> * e + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    visit(T[e]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">2</span>] != Nil) {</span><br><span class="line">        InTraverse(T, <span class="number">2</span> * e + <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!BiTreeEmpty(T)) {</span><br><span class="line">        InTraverse(T, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostTraverse</span><span class="params">(SqBiTree T,<span class="keyword">int</span> e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">1</span>] != Nil) {</span><br><span class="line">        PostTraverse(T, <span class="number">2</span> * e + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (T[<span class="number">2</span> * e + <span class="number">2</span>] != Nil) {</span><br><span class="line">        PostTraverse(T, <span class="number">2</span> * e + <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    visit(T[e]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(SqBiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(!BiTreeEmpty(T)) {</span><br><span class="line">        PostTraverse(T, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大结点数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> CElemType;</span><br><span class="line"><span class="keyword">typedef</span> CElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">CElemType Nil = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark--二叉树构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> indexs = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">String</span>[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">String</span> str;</span><br><span class="line"><span class="function">Status <span class="title">StrAssign</span><span class="params">(<span class="keyword">String</span> T,<span class="keyword">char</span> *chars)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(chars) &gt; <span class="number">100</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    T[<span class="number">0</span>] = <span class="built_in">strlen</span>(chars);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">        T[i] =* (chars + i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - BiTree</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> {</span></span><br><span class="line">    CElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">} BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(CElemType e)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, e);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span> </span>{</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBiTree</span><span class="params">(BiTree *T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*T) {</span><br><span class="line">        <span class="keyword">if</span> ((*T)-&gt;lchild) {</span><br><span class="line">            DestroyBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((*T)-&gt;rchild) {</span><br><span class="line">            DestroyBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClearBiTree DestroyBiTree</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span> </span>{</span><br><span class="line">    CElemType e = str[indexs++];</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="string">'#'</span>) {</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        (*T)-&gt;data = e;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> T == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild) {</span><br><span class="line">        i = BiTreeDepth(T-&gt;lchild);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (T-&gt;rchild) {</span><br><span class="line">        j = BiTreeDepth(T-&gt;rchild);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i &gt; j ? i + <span class="number">1</span> : j + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">Root</span><span class="params">(BiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (BiTreeEmpty(T)) {</span><br><span class="line">        <span class="keyword">return</span> Nil;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">CElemType <span class="title">Value</span><span class="params">(BiTree p)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(BiTree p, CElemType value)</span> </span>{</span><br><span class="line">    p-&gt;data=value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    InOrderTraverse(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">    InOrderTraverse(T-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-平衡二叉树</title>
      <link href="/posts/c5c3cf1/"/>
      <url>/posts/c5c3cf1/</url>
      
        <content type="html"><![CDATA[<p><strong>平衡二叉树</strong>（Balanced Binary Tree 或 Height-Balanced Tree）又称AVL树。它或者是一颗空树，或者具有下列性质的二叉树：</p><ul><li>它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</li><li>若将二叉树上结点的<strong>平衡因子</strong>BF(Balance Factor)定义为该结点的左子树的深度减去它的右子树深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0、1。</li></ul><p>一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树跟结点的指针为a，则失去平衡后进行调整的规律可归纳为下列4种情况：</p><ul><li>单向右旋平衡处理；</li><li>单向左旋平衡处理；</li><li>双向旋转（先左后右）平衡处理；</li><li>双向旋转（先右后左）平衡处理；</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">// 左高</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">// 等高</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">// 右高</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> bf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    </span><br><span class="line">}BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BSTree *p)</span> </span>{</span><br><span class="line">    BSTree lc;</span><br><span class="line">    lc = (*p)-&gt;lchild;</span><br><span class="line">    (*p)-&gt;lchild = lc-&gt;rchild;</span><br><span class="line">    lc-&gt;rchild = *p;</span><br><span class="line">    *p = lc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BSTree *p)</span> </span>{</span><br><span class="line">    BSTree rc;</span><br><span class="line">    rc = (*p)-&gt;rchild;</span><br><span class="line">    (*p)-&gt;rchild = rc-&gt;lchild;</span><br><span class="line">    rc-&gt;lchild = *p;</span><br><span class="line">    *p = rc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BSTree *T)</span> </span>{</span><br><span class="line">    BSTree lc, rd;</span><br><span class="line">    lc = (*T)-&gt;lchild;</span><br><span class="line">    <span class="keyword">switch</span> (lc-&gt;bf) {</span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">            (*T)-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">            R_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            rd = lc-&gt;rchild;</span><br><span class="line">            <span class="keyword">switch</span> (rd-&gt;bf) {</span><br><span class="line">                <span class="keyword">case</span> LH:</span><br><span class="line">                    (*T)-&gt;bf = RH;</span><br><span class="line">                    lc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH:</span><br><span class="line">                    (*T)-&gt;bf = lc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RH:</span><br><span class="line">                    (*T)-&gt;bf = EH;</span><br><span class="line">                    lc-&gt;bf = LH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            rd-&gt;bf = EH;</span><br><span class="line">            L_Rotate(&amp;(*T)-&gt;lchild);</span><br><span class="line">            R_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(BSTree *T)</span> </span>{</span><br><span class="line">    BSTree rc, ld;</span><br><span class="line">    rc = (*T)-&gt;rchild;</span><br><span class="line">    <span class="keyword">switch</span> (rc-&gt;bf) {</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            (*T)-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">            L_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">            ld = rc-&gt;lchild;</span><br><span class="line">            <span class="keyword">switch</span> (ld-&gt;bf) {</span><br><span class="line">                <span class="keyword">case</span> RH:</span><br><span class="line">                    (*T)-&gt;bf = LH;</span><br><span class="line">                    rc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH:</span><br><span class="line">                    (*T)-&gt;bf = rc-&gt;bf = EH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LH:</span><br><span class="line">                    (*T)-&gt;bf = EH;</span><br><span class="line">                    rc-&gt;bf = RH;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            ld-&gt;bf = EH;</span><br><span class="line">            R_Rotate(&amp;(*T)-&gt;rchild);</span><br><span class="line">            L_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BSTree *T, <span class="keyword">int</span> e, Status *taller)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!*T) {</span><br><span class="line">        *T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        (*T)-&gt;data = e;</span><br><span class="line">        (*T)-&gt;lchild = (*T)-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        (*T)-&gt;bf = EH;</span><br><span class="line">        *taller = TRUE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (e == (*T)-&gt;data) {</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e &lt; (*T)-&gt;data) {</span><br><span class="line">            <span class="keyword">if</span> (!InsertAVL(&amp;(*T)-&gt;lchild, e, taller)) {</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (*taller) {</span><br><span class="line">                    <span class="keyword">switch</span> ((*T)-&gt;bf) {</span><br><span class="line">                        <span class="keyword">case</span> LH:</span><br><span class="line">                            LeftBalance(T);</span><br><span class="line">                            *taller = FALSE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> EH:</span><br><span class="line">                            (*T)-&gt;bf = LH;</span><br><span class="line">                            *taller = TRUE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> RH:</span><br><span class="line">                            (*T)-&gt;bf = EH;</span><br><span class="line">                            *taller = FALSE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!InsertAVL(&amp;(*T)-&gt;rchild, e, taller)) {</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (*taller) {</span><br><span class="line">                    <span class="keyword">switch</span> ((*T)-&gt;bf) {</span><br><span class="line">                        <span class="keyword">case</span> RH:</span><br><span class="line">                            RightBalance(T);</span><br><span class="line">                            *taller = FALSE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> EH:</span><br><span class="line">                            (*T)-&gt;bf = RH;</span><br><span class="line">                            *taller = TRUE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> LH:</span><br><span class="line">                            (*T)-&gt;bf = EH;</span><br><span class="line">                            *taller = FALSE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BSTree T, <span class="keyword">int</span> key, BSTree f, BSTree *p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (!T) {</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data) {</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data) {</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-BMP算法</title>
      <link href="/posts/c81c5dcf/"/>
      <url>/posts/c81c5dcf/</url>
      
        <content type="html"><![CDATA[<p>KMP算法是一种改进的<code>字符串匹配</code>算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。<br>KMP算法的时间复杂度<code>O(M + N)</code>。</p><h1 id="KMP算法原理"><a href="#KMP算法原理" class="headerlink" title="KMP算法原理"></a>KMP算法原理</h1><h4 id="部分匹配表（Partial-Match-Table）如何计算"><a href="#部分匹配表（Partial-Match-Table）如何计算" class="headerlink" title="部分匹配表（Partial Match Table）如何计算"></a>部分匹配表（Partial Match Table）如何计算</h4><p>首先，要理解两个概念：</p><ul><li>前缀：指除了最后一个字符以外，一个字符串的全部头部组合;</li><li>后缀：指除了第一个字符以外，一个字符串的全部尾部组合。</li></ul><p><code>部分匹配值</code>就是指<code>前缀</code>和<code>后缀</code>的最长共有元素的长度。</p><h1 id="KMP代码实现"><a href="#KMP代码实现" class="headerlink" title="KMP代码实现"></a>KMP代码实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> KMP 算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> *next)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || T[i] == T[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[j] = i;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = next[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> next[MAXSIZE];</span><br><span class="line">    get_next(T, next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> KMP优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> *next)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || T[i] == T[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j]) {</span><br><span class="line">                next[j] = i;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                next[j] = next[i];</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = next[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> next[MAXSIZE];</span><br><span class="line">    get_next(T, next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            j = next[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-BF&amp;RK算法</title>
      <link href="/posts/f97d4669/"/>
      <url>/posts/f97d4669/</url>
      
        <content type="html"><![CDATA[<p>有一个主串S = {a, b, c, a, c, a, b, d, c}, 模式串T = { a, b, d } ; 请找到模式串在主串中第一次出现的位置;<br>提示: 不需要考虑字符串大小写问题, 字符均为小写字母</p><h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p>BF算法，即暴力(Brute Force)算法，是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。</p><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则S向右移动一个字符的位置，再依次进行比较。如果存在k，1≤k≤N，且S[k+1…k+M]=T[1…M]，则匹配成功；否则失败。<br>该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M * N)。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) {</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p>RK 算法的全称叫作 Rabin-Karp 算法，是为了纪念它的两个发明者而这样命名的。 这个算法其实就是刚刚 BF 算法的升级版。</p><p>在 BF 算法中，每次都要对 m 个字符逐个进行比较，这就大大降低了算法的效率。这时候，我们引入哈希算法，对子串逐个求哈希值，然后与模式串的哈希值进行比较来判断两个子串是否匹配。在不考虑哈希冲突的情况下，数字之间的比较就非常快了。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>1.首先把字母转换成数字，<code>将字母-'a'的值单纯字母的对应的数字</code></p><blockquote><p>例如<br>  a - a = 0;<br>  b - a = 1;<br>  c - a = 2;</p></blockquote><ol start="2"><li>将小写字母字符串转换成数字，利用字母26进制<blockquote><p>例如<br>“cba” = <code>'c'</code> * 26 ^ 2 + <code>'b'</code> * 26 ^ 1 + <code>'a'</code> * 26 ^ 0<br>“cba” =  <code>2</code> * 26 ^ 2 + <code>1</code> * 26 ^ 1 + <code>0</code> * 26 ^ 0</p></blockquote></li><li>主串拆分的子串之间的关系<blockquote><p>例如<br>主串： <code>d b c</code> e d b<br>= <code>3</code> * 26 ^ 2 + <code>1</code> * 26 ^ 1 + <code>2</code> * 26 ^ 0<br>主串： d <code>b c e</code> d b<br>= <code>1</code> * 26 ^ 2 + <code>2</code> * 26 ^ 1 + <code>4</code> * 26 ^ 0</p></blockquote></li></ol><p>子串哈希值求解的规律：</p><blockquote><p>相邻的2个子串s[i]与s[i + 1]，对应的哈希值计算公式有交集，也就是说我们可以使用s[i - 1] 计算出s[i]的哈希值。</p></blockquote><p><code>St[i] = (St[i - 1] - d ^ (m - 1) * (s[i] - 'a')) * d + (s[i + m] - 'a')</code></p><ol start="4"><li>处理哈希冲突<ul><li>设计更复杂的哈希公式</li><li>如果哈希值相等，重新核实</li></ul></li></ol><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d 26</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">int</span> i, <span class="keyword">char</span> *P, <span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> is, ip;</span><br><span class="line">    <span class="keyword">for</span> (is = i, ip = <span class="number">0</span>; is != m &amp;&amp; ip != m; is++, ip++) {</span><br><span class="line">        <span class="keyword">if</span> (S[is] != P[ip]) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> d ^ (m - 1) 位的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span> m)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) {</span><br><span class="line">        j = j * d;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *P)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(P);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> St = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m; i++) {</span><br><span class="line">        A = (d * A + (P[i] - <span class="string">'a'</span>));</span><br><span class="line">        St = (d * St + (S[i] - <span class="string">'a'</span>));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> hValue = getMaxValue(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">        <span class="keyword">if</span> (A == St &amp;&amp; isMatch(S, i, P, m)) {</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        St = (St - hValue * (S[i] - <span class="string">'a'</span>)) * d + (S[i + m] - <span class="string">'a'</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去除重复字母（LeetCode-316)</title>
      <link href="/posts/af63c235/"/>
      <url>/posts/af63c235/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters" target="_blank" rel="noopener">LeetCode-316</a><br>给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入: “bcabc”<br>   输出: “abc”</p></blockquote><blockquote><p>输入: “cbacdcbc”<br>   输出: “acdb”</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>初始化一个数组record[26];</li><li>遍历s记录每个字母出现的次数;</li><li>申请一个字符串栈stack用来存储去除重复字母的结果，遍历s进行入栈；</li><li>遍历栈，如果s[i]存在于栈中，则record[s[i] - ‘a’]–,并且继续下一次遍历；</li><li>否则比较栈顶字母和s[i]的大小，如果stack[top]&gt;s[i]并且record[stack[top]-‘a’]&gt;1(说明stack[top]在后边还会出现)就出栈，并且record[s[i]-’a‘]–；</li><li>入栈；</li><li>最后stack[++top]=’\0‘转成字符串;</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">removeDuplicateLetters</span><span class="params">(<span class="keyword">char</span> * s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; len == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> record[<span class="number">26</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * len &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">        record[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">        <span class="keyword">int</span> isExist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= top; j++) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stack</span>[j] == s[i]) {</span><br><span class="line">                isExist = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isExist == <span class="number">1</span>) {</span><br><span class="line">            record[s[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">-1</span> &amp;&amp; <span class="built_in">stack</span>[top] &gt; s[i] &amp;&amp; record[<span class="built_in">stack</span>[top] - <span class="string">'a'</span>] &gt; <span class="number">1</span>) {</span><br><span class="line">                record[<span class="built_in">stack</span>[top] - <span class="string">'a'</span>]--;</span><br><span class="line">                top--;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">stack</span>[++top] = s[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈思想-算法题解</title>
      <link href="/posts/6a59d3f0/"/>
      <url>/posts/6a59d3f0/</url>
      
        <content type="html"><![CDATA[<h1 id="栈思想"><a href="#栈思想" class="headerlink" title="栈思想"></a>栈思想</h1><p>指的是利用栈的特性(先进后出)去解决问题，那么什么问题适合用栈思想解决了?</p><ol><li>数据是线性的。</li><li>问题中常常涉及到数据的来回比较、匹配问题。<br>例如：每日温度、括号匹配、字符串解码、去掉重复字母等问题。</li><li>问题中涉及到数据的转置。<br>例如：进制问题、链表倒序打印问题等</li></ol><blockquote><p>注意并不是说栈思想只是一个解决的的参考思想，并不是万能的，它适用于以上这样的情况下去解决问题；<br>利用栈思想解决问题时，首先需要透彻的解析问题之后，找到问题解决的规律，才能使用它解决。<br>思想只有指导作用,遇到不同的题目,需要个例分析.在基本思想上去找到解决问题之道。</p></blockquote><h1 id="算法题解"><a href="#算法题解" class="headerlink" title="算法题解"></a>算法题解</h1><h2 id="1-有效的括号-Leetcode-20"><a href="#1-有效的括号-Leetcode-20" class="headerlink" title="1. 有效的括号 (Leetcode-20)"></a>1. <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号 (Leetcode-20)</a></h2><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断字符串是否有效。<br>有效字符串需满足:</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><blockquote><p>输入：”()”<br>输出：true</p></blockquote><h5 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h5><blockquote><p>输入：”([)]”<br>输出：false</p></blockquote><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4></li><li>遇见左字符，将做字符入栈</li><li>遇见右字符<ul><li>如果栈是空的，说明<code>括号无效</code></li><li>如果栈不为空，将栈顶字符出栈，与右字符匹配<ul><li>如果左右字符不匹配，说明<code>括号无效</code></li><li>如果左右字符匹配，继续扫描下一个字符</li></ul></li></ul></li><li>所有字符扫描完毕后<ul><li>栈为空， 说明<code>括号有效</code></li><li>栈不为空，说明<code>括号无效</code></li></ul></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * s)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (len &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[len];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'{'</span> || s[i] == <span class="string">'['</span>) {</span><br><span class="line">            <span class="built_in">stack</span>[++top] = s[i];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (top == <span class="number">-1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="built_in">stack</span>[top] + <span class="number">1</span> || s[i] == <span class="built_in">stack</span>[top] + <span class="number">2</span>) {</span><br><span class="line">            top--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-数制转换"><a href="#2-数制转换" class="headerlink" title="2. 数制转换"></a>2. 数制转换</h2><p>给定一个整数，将其转化为八进制，并以字符串形式输出。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conversion</span><span class="params">(<span class="keyword">int</span> N)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[N];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N) {</span><br><span class="line">        <span class="built_in">stack</span>[++top] = N % <span class="number">8</span>;</span><br><span class="line">        N = N / <span class="number">8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">stack</span>[top--]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-杨辉三角"><a href="#3-杨辉三角" class="headerlink" title="3. 杨辉三角"></a>3. 杨辉三角</h2><p>给定一个非负整数 num，生成杨辉三角的前 num 行。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><ol><li>第一层循环行数i: 默认[i][0] = 1,[i][i] = 1</li><li>第二层循环控制列数j : triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows, <span class="keyword">int</span> * returnSize)</span> </span>{</span><br><span class="line">    *returnSize = numRows;</span><br><span class="line">    <span class="keyword">int</span> ** res = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * numRows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) {</span><br><span class="line">        res[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * i);</span><br><span class="line">        res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        res[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) {</span><br><span class="line">            res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-爬楼梯问题"><a href="#4-爬楼梯问题" class="headerlink" title="4. 爬楼梯问题"></a>4. 爬楼梯问题</h2>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><blockquote><p>f(1) = 1;<br>f(2) = 2;<br>f(n) = f(n - 1) + f(n - 2)</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *sum = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    sum[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + sum[i - <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="4-每日气温"><a href="#4-每日气温" class="headerlink" title="4. 每日气温"></a>4. 每日气温</h2><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。<br>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入: [73, 74, 75, 71, 69, 72, 76, 73]<br>   输出: [1, 1, 4, 2, 1, 1, 0, 0]</p></blockquote><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>跳跃对比，倒序遍历，利用已经有结果的位置进行跳跃，减少遍历次数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 思路:</span></span><br><span class="line"><span class="comment"> 1.创建一个result 结果数组.</span></span><br><span class="line"><span class="comment"> 2.默认reslut[TSize-1] = 0;</span></span><br><span class="line"><span class="comment"> 3.从TSize-2个元素遍历到第一个元素[TSize-2,0];</span></span><br><span class="line"><span class="comment"> 4.从[i+1,TSize]遍历,j+=result[j];</span></span><br><span class="line"><span class="comment">    -若T[i]&lt;T[j],那么Result = j - i;</span></span><br><span class="line"><span class="comment">    -若reuslt[j] == 0,则表示后面不会有更大的值,那么当前值就应该也是0;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">dailyTemperatures</span><span class="params">(<span class="keyword">int</span> * T, <span class="keyword">int</span> TSize, <span class="keyword">int</span> * returnSize)</span> </span>{</span><br><span class="line">    *returnSize = TSize;</span><br><span class="line">    <span class="keyword">int</span> *result = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * TSize);</span><br><span class="line">    result[TSize - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = TSize - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; TSize; j += result[j]) {</span><br><span class="line">            <span class="keyword">if</span> (T[i] &lt; T[j]) {</span><br><span class="line">                result[i] = j - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (result[j] == <span class="number">0</span>) {</span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路:</span></span><br><span class="line"><span class="comment">1. 初始化一个栈(用来存储索引),value数组</span></span><br><span class="line"><span class="comment">2. 栈中存储的是元素的索引值index;</span></span><br><span class="line"><span class="comment">3. 遍历整个温度数组从[0,TSize];</span></span><br><span class="line"><span class="comment">   (1).如果栈顶元素&lt;当前元素,则将当前元素索引index-栈顶元素index,计算完毕则将当前栈顶元素移除,将当前元素索引index 存储到栈中; 出栈后,只要栈不为空.继续比较,直到栈顶元素不能满足T[i] &gt; T[stack_index[top-1]]</span></span><br><span class="line"><span class="comment">(2).如果当前的栈为空,则直接入栈;</span></span><br><span class="line"><span class="comment">(3).如果当前的元素小于栈顶元素,则入栈</span></span><br><span class="line"><span class="comment">(4).while循环结束后,当前元素也需要入栈;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">dailyTemperatures</span><span class="params">(<span class="keyword">int</span> * T, <span class="keyword">int</span> TSize, <span class="keyword">int</span> * returnSize)</span> </span>{</span><br><span class="line">    *returnSize = TSize;</span><br><span class="line">    <span class="keyword">int</span> *result = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * TSize);</span><br><span class="line">    <span class="keyword">int</span> *stack_index = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * TSize);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TSize; i++) {</span><br><span class="line">        result[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; T[i] &gt; T[stack_index[top - <span class="number">1</span>]]) {</span><br><span class="line">            tIndex = stack_index[top - <span class="number">1</span>];</span><br><span class="line">            result[tIndex] = i - tIndex;</span><br><span class="line">            top--;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        stack_index[top] = i;</span><br><span class="line">        top++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-字符串解码-Leetcode-394"><a href="#5-字符串解码-Leetcode-394" class="headerlink" title="5. 字符串解码 (Leetcode-394)"></a>5. <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码 (Leetcode-394)</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h4><blockquote><p>s = “3[a]2[bc]”, 返回 “aaabcbc”.<br>  s = “3[a2[c]]”, 返回 “accaccacc”.<br>  s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”.</p></blockquote><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><ol><li>遍历字符串 S</li><li>如果当前字符不为方括号”]” 则入栈stack中;</li><li>如果当前字符遇到了方括号”]” 则:</li><li>1 首先找到要复制的字符,例如stack=”12[a”,那么我要首先获取字符a;将这个a保存在另外一个栈去tempStack;</li><li>2 接下来,要找到需要备份的数量,例如stack=”12[a”,因为出栈过字符”a”,则当前的top指向了”[“,也就是等于2;</li><li>3 而12对于字符串是2个字符, 我们要通过遍历找到数字12的top上限/下限的位置索引, 此时上限curTop = 2, 下限通过出栈,top = -1;</li><li>4 根据范围[-1,2],读取出12保存到strOfInt 字符串中来, 并且将字符”12\0”,转化成数字12;</li><li>5 当前top=-1,将tempStack中的字符a,复制12份入栈到stack中来;</li><li>6 为当前的stack扩容, 在stack字符的末尾添加字符结束符合’\0’;</li></ol><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">decodeString</span><span class="params">(<span class="keyword">char</span> * s)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> stackSize = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * stackSize);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">']'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (top == stackSize - <span class="number">1</span>) {</span><br><span class="line">                <span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(<span class="built_in">stack</span>, (stackSize += <span class="number">50</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">stack</span>[++top] = s[i];</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> strStackSize = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">char</span> *strStack = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * strStackSize);</span><br><span class="line">            <span class="keyword">int</span> strTop = <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">stack</span>[top] != <span class="string">'['</span>) {</span><br><span class="line">                <span class="keyword">if</span> (strTop == strStackSize - <span class="number">1</span>) {</span><br><span class="line">                    strStack = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(strStack, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (strStackSize += <span class="number">10</span>));</span><br><span class="line">                }</span><br><span class="line">                strStack[++strTop] = <span class="built_in">stack</span>[top--];</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line"><span class="comment">//            char kStack[11];</span></span><br><span class="line"><span class="comment">//            int currentTop = top;</span></span><br><span class="line"><span class="comment">//            top--;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while (top != -1 &amp;&amp; stack[top] &gt;= '0' &amp;&amp; stack[top] &lt;= '9') {</span></span><br><span class="line"><span class="comment">//                top--;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            for (int j = top + 1; j &lt; currentTop; j++) {</span></span><br><span class="line"><span class="comment">//                kStack[j - (top + 1)] = stack[j];</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            kStack[currentTop - (top + 1)] = '\0';</span></span><br><span class="line"><span class="comment">//            int curNum = atoi(kStack);</span></span><br><span class="line">            </span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">int</span> curNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; <span class="built_in">stack</span>[top] &gt;= <span class="string">'0'</span> &amp;&amp; <span class="built_in">stack</span>[top] &lt;= <span class="string">'9'</span>) {</span><br><span class="line">                curNum += (<span class="built_in">stack</span>[top] - <span class="string">'0'</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, j++);</span><br><span class="line">                top--;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; curNum; k++) {</span><br><span class="line">                <span class="keyword">int</span> tempTop = strTop;</span><br><span class="line">                <span class="keyword">while</span> (tempTop != <span class="number">-1</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (top == stackSize - <span class="number">1</span>) {</span><br><span class="line">                        <span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(<span class="built_in">stack</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (stackSize += <span class="number">50</span>));</span><br><span class="line">                    }</span><br><span class="line">                    <span class="built_in">stack</span>[++top] = strStack[tempTop--];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> *result = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(<span class="built_in">stack</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (top + <span class="number">2</span>));</span><br><span class="line">    result[++top] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-队列</title>
      <link href="/posts/a1a48993/"/>
      <url>/posts/a1a48993/</url>
      
        <content type="html"><![CDATA[<p><strong>队列</strong>是一种特殊的线性表，只能在头尾两端进行操作。</p><ul><li>队尾（rear）：只能从队尾添加元素，一般叫做enQueue，入队</li><li>对头（front）：只能从队头移除元素，一般叫做deQueue, 出队</li><li>先进先出的原则，First in first out， FIFO<h2 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h2><h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    QElemType data[QUEUE_INIT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">}SqQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span> </span>{</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取对头元素"><a href="#获取对头元素" class="headerlink" title="获取对头元素"></a>获取对头元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q, QElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    *e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % QUEUE_INIT_SIZE == Q-&gt;front) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % QUEUE_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % QUEUE_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="队列的清空"><a href="#队列的清空" class="headerlink" title="队列的清空"></a>队列的清空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue *Q)</span> </span>{</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列判断是否为空"><a href="#队列判断是否为空" class="headerlink" title="队列判断是否为空"></a>队列判断是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列的长度"><a href="#队列的长度" class="headerlink" title="队列的长度"></a>队列的长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + QUEUE_INIT_SIZE) % QUEUE_INIT_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><h3 id="结构设计-1"><a href="#结构设计-1" class="headerlink" title="结构设计"></a>结构设计</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> {</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}QueueNode, *QueueNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    QueueNodePtr front;</span><br><span class="line">    QueueNodePtr rear;</span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="队列的创建-1"><a href="#队列的创建-1" class="headerlink" title="队列的创建"></a>队列的创建</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span> </span>{</span><br><span class="line">    Q-&gt;rear = Q-&gt;front = (QueueNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取对头元素-1"><a href="#获取对头元素-1" class="headerlink" title="获取对头元素"></a>获取对头元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q, QElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    *e = Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span> </span>{</span><br><span class="line">    QueueNodePtr temp = (QueueNodePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    temp-&gt;data = e;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = temp;</span><br><span class="line">    Q-&gt;rear = temp;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    QueueNodePtr p;</span><br><span class="line">    p = Q-&gt;front-&gt;next;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p) {</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列的销毁"><a href="#队列的销毁" class="headerlink" title="队列的销毁"></a>队列的销毁</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue *Q)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (Q-&gt;front) {</span><br><span class="line">        Q-&gt;rear = Q-&gt;front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q-&gt;front);</span><br><span class="line">        Q-&gt;front = Q-&gt;rear;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列的清除"><a href="#队列的清除" class="headerlink" title="队列的清除"></a>队列的清除</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue *Q)</span> </span>{</span><br><span class="line">    QueueNodePtr p, q;</span><br><span class="line">    Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    p = Q-&gt;front-&gt;next;</span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列判断是否为空-1"><a href="#队列判断是否为空-1" class="headerlink" title="队列判断是否为空"></a>队列判断是否为空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="队列的长度-1"><a href="#队列的长度-1" class="headerlink" title="队列的长度"></a>队列的长度</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    QueueNodePtr p = Q.front;</span><br><span class="line">    <span class="keyword">while</span> (Q.rear != p) {</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-栈</title>
      <link href="/posts/e79f629f/"/>
      <url>/posts/e79f629f/</url>
      
        <content type="html"><![CDATA[<p>栈和队列是两种重要的现行结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>栈</strong>(stack) 是限定尽在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端称为<strong>栈顶</strong>（top）, 表头端称为<strong>栈底</strong>（bottom）。不含元素的空表称为空栈。</p><h1 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h1><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元一次存放自栈底到栈顶的数据元素同时附设指针top指示栈顶元素在顺序栈中的位置。通常的习惯做法是以top = 0表示空栈。 </p><h3 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    SElemType data[STACK_INIT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">}SqStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的创建"><a href="#顺序栈的创建" class="headerlink" title="顺序栈的创建"></a>顺序栈的创建</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *S)</span> </span>{</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    *e = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的压栈"><a href="#顺序栈的压栈" class="headerlink" title="顺序栈的压栈"></a>顺序栈的压栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S, SElemType e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == STACK_INIT_SIZE - <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    S-&gt;top ++;</span><br><span class="line">    S-&gt;data[S-&gt;top] = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的出栈"><a href="#顺序栈的出栈" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S, SElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    *e = S-&gt;data[S-&gt;top];</span><br><span class="line">    S-&gt;top --;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的清空"><a href="#顺序栈的清空" class="headerlink" title="顺序栈的清空"></a>顺序栈的清空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack *S)</span> </span>{</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的为空判断"><a href="#顺序栈的为空判断" class="headerlink" title="顺序栈的为空判断"></a>顺序栈的为空判断</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> S.top == <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的遍历"><a href="#顺序栈的遍历" class="headerlink" title="顺序栈的遍历"></a>顺序栈的遍历</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(SqStack S)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.top) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, S.data[i++]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h2 id="结构设计-1"><a href="#结构设计-1" class="headerlink" title="结构设计"></a>结构设计</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> {</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">}StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的创建-1"><a href="#顺序栈的创建-1" class="headerlink" title="顺序栈的创建"></a>顺序栈的创建</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack *S)</span> </span>{</span><br><span class="line">    S-&gt;top = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取栈顶元素-1"><a href="#获取栈顶元素-1" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(LinkStack S, SElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (S.count == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    *e = S.top-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的压栈-1"><a href="#顺序栈的压栈-1" class="headerlink" title="顺序栈的压栈"></a>顺序栈的压栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S, SElemType e)</span> </span>{</span><br><span class="line">    LinkStackPtr temp = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    <span class="keyword">if</span> (!temp) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    temp-&gt;data = e;</span><br><span class="line">    temp-&gt;next = S-&gt;top;</span><br><span class="line">    S-&gt;top = temp;</span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的出栈-1"><a href="#顺序栈的出栈-1" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S, SElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;count == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    *e = S-&gt;top-&gt;data;</span><br><span class="line">    LinkStackPtr p = S-&gt;top;</span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的清空-1"><a href="#顺序栈的清空-1" class="headerlink" title="顺序栈的清空"></a>顺序栈的清空</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(LinkStack *S)</span> </span>{</span><br><span class="line">    LinkStackPtr p, q;</span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    }</span><br><span class="line">    S-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的为空判断-1"><a href="#顺序栈的为空判断-1" class="headerlink" title="顺序栈的为空判断"></a>顺序栈的为空判断</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> S.count == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="顺序栈的遍历-1"><a href="#顺序栈的遍历-1" class="headerlink" title="顺序栈的遍历"></a>顺序栈的遍历</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackTraverse</span><span class="params">(LinkStack S)</span> </span>{</span><br><span class="line">    LinkStackPtr p = S.top;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表中删除相等的多余结点</title>
      <link href="/posts/195c875e/"/>
      <url>/posts/195c875e/</url>
      
        <content type="html"><![CDATA[<p>用单链表保存m个整数, 结点的结构为(data,link),且|data|&lt;=n(n为正整数). 现在要去设计一个时间复杂度尽可能高效的算法. 对于链表中的data 绝对值相等的结点, 仅保留第一次出现的结点,而删除其余绝对值相等的结点.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：0-&gt;2-&gt;-2-&gt;6-&gt;2-&gt;10</span><br><span class="line">输出：0-&gt;2-&gt;6-&gt;10</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ol><li>申请大小为n+1的辅助数组t并赋值初值为0；</li><li>从首元结点开始遍历链表,依次检查t[|data|]的值<br>– 若[|data|]为0,即结点首次出现,则保留该结点,并置t[|data|] = 1<br>– 若t[|data|]不为0,则将该结点从链表中删除.<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteEqualNode</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    LinkList q = *L;</span><br><span class="line">    LinkList r = (*L)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (r) {</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="built_in">abs</span>(r-&gt;data)] == <span class="number">1</span>) {</span><br><span class="line">            q-&gt;next = r-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(r);</span><br><span class="line">            r = q-&gt;next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p[<span class="built_in">abs</span>(r-&gt;data)] = <span class="number">1</span>;</span><br><span class="line">            q = r;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找数组中的主元素</title>
      <link href="/posts/6c088b74/"/>
      <url>/posts/6c088b74/</url>
      
        <content type="html"><![CDATA[<p>已知一个整数序列A = (a0,a1,a2,…an-1),其中(0&lt;= ai &lt;=n),(0&lt;= i&lt;=n). 若存在ap1= ap2 = …= apm = x,且m&gt;n/2(0&lt;=pk&lt;n,1&lt;=k&lt;=m),则称x 为 A的主元素. 例如,A = (0,5,5,3,5,7,5,5),则5是主元素; 若B = (0,5,5,3,5,1,5,7),则A 中没有主元素,假设A中的n个元素保存在一个一维数组中,请设计一个尽可能高效的算法,找出数组元素中的主元素,若存在主元素则输出该元素,否则输出-1.</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = (0, 5, 5, 3, 5, 7, 5, 5)</span><br><span class="line">输出：5</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>所谓主元素就是在一个数组中的某一个元素所出现的的次数大于大于数组长度的1/2</p><ol><li>选取候选的主要元素：依次扫描所给数组中的每一个整数，将第一个遇到的整数i保存到c中，记录i出现的次数为1，若遇到的下一个整数仍等于i，则计算器加1，否则计数器减1，当计数器减到0时，将遇到的下一个整数保存到x中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部元素。</li><li>判断x中元素是否是真正的主元素：再次扫描该数组，统计x中元素出现的次数，若大于n/2，则为主元素，否则序列中不存在主元素。<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MainElement</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> x = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (x == A[i]) {</span><br><span class="line">            count++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                count--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                x = A[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (A[i] == x) {</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &gt; n / <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组元素左移</title>
      <link href="/posts/496308ba/"/>
      <url>/posts/496308ba/</url>
      
        <content type="html"><![CDATA[<p>设将n(n&gt;1)个整数存放到一维数组R中, 试设计一个在时间和空间两方面都尽可能高效的算法;将R中保存的序列循环左移p个位置(0&lt;p&lt;n)个位置, 即将R中的数据由(x0,x1,……,xn-1)变换为(xp,xp+1,…,xn-1,x0,x1,…,xp-1)。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pre[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, </span><br><span class="line">     n = 10, p = 3</span><br><span class="line">输出：pre[10] = {3, 4, 5, 6, 7, 8, 9, 0, 1, 2}</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>先逆置整个数组，再逆置前n-p个元素和后面的p个元素</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> *pre, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">        temp = pre[i];</span><br><span class="line">        pre[i] = pre[j];</span><br><span class="line">        pre[j] = temp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotateLeft</span><span class="params">(<span class="keyword">int</span> *pre, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span> &amp;&amp; p &lt; n) {</span><br><span class="line">        Reverse(pre, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        Reverse(pre, <span class="number">0</span>, n <span class="number">-1</span> - p);</span><br><span class="line">        Reverse(pre, n - p, n - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除递增有序链表中值大于等于mink且小于等于maxk</title>
      <link href="/posts/e5f24551/"/>
      <url>/posts/e5f24551/</url>
      
        <content type="html"><![CDATA[<p>设计一个算法,删除递增有序链表中值大于等于mink且小于等于maxk(mink,maxk是给定的两个参数,其值可以和表中的元素相同,也可以不同)的所有元素;</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：0-&gt;2-&gt;4-&gt;6-&gt;8-&gt;10，mink = 4, maxk = 8</span><br><span class="line">输出：1-&gt;2-&gt;10</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>分别查找第一个值&gt;mink的结点和第一个值 ≥maxk的结点，再修改指针，删除值大于mink且小于maxk的所有元素。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteMinMax</span><span class="params">(LinkList *L, <span class="keyword">int</span> mink, <span class="keyword">int</span> maxk)</span> </span>{</span><br><span class="line">    LinkList p, q, pre, temp;</span><br><span class="line">    pre = *L;</span><br><span class="line">    p = (*L)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data &lt; mink) {</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data &lt;= maxk) {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    q = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q != p) {</span><br><span class="line">        temp = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原地旋转链表</title>
      <link href="/posts/c51766e2/"/>
      <url>/posts/c51766e2/</url>
      
        <content type="html"><![CDATA[<p>设计一个算法,将链表中所有节点的链接方向”原地旋转”,即要求仅仅利用原表的存储空间. 换句话说,要求算法空间复杂度为O(1);</p><h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><ul><li>算法空间复杂度为O(1)<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：0-&gt;2-&gt;4-&gt;6-&gt;8-&gt;10</span><br><span class="line">输出：10-&gt;8-&gt;6-&gt;4-&gt;2-&gt;0</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4>要求算法空间复杂度为O(1)，即不能开辟新的空间，只能考虑改变指针指向，参考前插法的思想。<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4></li><li>空间复杂度 O(1)</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inverse</span><span class="params">(LinkList *L)</span> </span>{</span><br><span class="line">    LinkList p, temp;</span><br><span class="line">    p = (*L)-&gt;next;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = (*L)-&gt;next;</span><br><span class="line">        (*L)-&gt;next = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个递增链表的交集</title>
      <link href="/posts/528dc7d4/"/>
      <url>/posts/528dc7d4/</url>
      
        <content type="html"><![CDATA[<p>已知两个链表A和B分别表示两个集合.其元素递增排列. 设计一个算法,用于求出A与B的交集,并存储在A链表中;</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：2-&gt;4-&gt;6-&gt;8,  4-&gt;6-&gt;8-&gt;10</span><br><span class="line">输出：4-&gt;6-&gt;8</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ol><li>只有同时出现在两集合中的元素才出现在结果表中，合并后的新表使用头指针Lc指向。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点;</li><li>遍历，判断节点元素是否相等<br> – 相等，取A表中元素，删除B表中元素<br> – 不相等，删除最小的元素</li><li>当链表有一个先到表尾，依次删除另一个非空表中的所有元素；</li><li>释放链表B;<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4></li></ol><ul><li>时间复杂度O(n)</li><li>空间复杂度 O(1)<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Intersection</span><span class="params">(LinkList *La, LinkList *Lb, LinkList *Lc)</span> </span>{</span><br><span class="line">    LinkList pa, pb, pc, temp;</span><br><span class="line">    pa = (*La)-&gt;next;</span><br><span class="line">    pb = (*Lb)-&gt;next;</span><br><span class="line">    *Lc = pc = *La;</span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) {</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data &lt; pb-&gt;data) {</span><br><span class="line">            temp = pa-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(pa);</span><br><span class="line">            pa = temp;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (pa-&gt;data &gt; pb-&gt;data) {</span><br><span class="line">            temp = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(pb);</span><br><span class="line">            pb = temp;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line"></span><br><span class="line">            temp = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    LinkList pd = pa ? pa: pb;</span><br><span class="line">    <span class="keyword">while</span> (pd) {</span><br><span class="line">        temp = pd;</span><br><span class="line">        pd = pd-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    pc-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(*Lb);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个排序的链表</title>
      <link href="/posts/faa1cd64/"/>
      <url>/posts/faa1cd64/</url>
      
        <content type="html"><![CDATA[<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h4 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h4><ul><li>结果链表仍然使用两个链表的存储空间，不另外占用其他的存储空间；</li><li>表中不允许有重复的数据；<h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></tbody></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4>根据题目描述，链表La，Lb是递增的，因此很容易想到使用双指针便利两个链表，根据判断大小关系确定节点添加顺序，两节点指针交替进行，直至遍历完毕；<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4></li><li>时间复杂度O(M + N)：M，N分别为链表的长度。</li><li>空间复杂度 O(1)<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeTwoLists</span><span class="params">(LinkList *La, LinkList *Lb, LinkList *Lc)</span> </span>{</span><br><span class="line">    LinkList pa, pb, pc, temp;</span><br><span class="line">    pa = (*La)-&gt;next;</span><br><span class="line">    pb = (*Lb)-&gt;next;</span><br><span class="line">    *Lc = pc = *La;</span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) {</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data &lt; pb-&gt;data) {</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (pa-&gt;data &gt; pb-&gt;data) {</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line"></span><br><span class="line">            temp = pb-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(pb);</span><br><span class="line">            pb = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pc-&gt;next = pa == <span class="literal">NULL</span> ? pb : pa;</span><br><span class="line">    <span class="built_in">free</span>(*Lb);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-双向链表</title>
      <link href="/posts/9c051e67/"/>
      <url>/posts/9c051e67/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><hr><h2 id="双向链表的结构"><a href="#双向链表的结构" class="headerlink" title="双向链表的结构"></a>双向链表的结构</h2><p>双向链表的结点包括三个部分：前驱指针域、数据域和后继指针域：</p><ul><li>前驱指针域，又称为左链指针，用于存放一个指针，该指针指向上一个结点的开始存储地址；</li><li>数据域，用于存储该结点的数据元素，数据元素类型由应用问题决定。</li><li>后继指针域，又称为右链指针，用于存放一个指针，该指针指向下一个结点的开始存储地址。</li></ul><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-32efb37d30ad8f22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3086262-2fd9b782a9780da6.png"></p><h2 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h2><h3 id="结构体设计"><a href="#结构体设计" class="headerlink" title="结构体设计"></a>结构体设计</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateLinkList</span><span class="params">(LinkList *L)</span> </span>{</span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*L)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    (*L)-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">        LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">        temp-&gt;data = i;</span><br><span class="line">        temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListInsert</span><span class="params">(LinkList *L, <span class="keyword">int</span> place, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (place &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    temp-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;data = num;</span><br><span class="line">    </span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; place &amp;&amp; p != <span class="literal">NULL</span>; i++) {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        temp-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior = temp;</span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="双向链表的删除"><a href="#双向链表的删除" class="headerlink" title="双向链表的删除"></a>双向链表的删除</h3><p>删除指定位置</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListDelete</span><span class="params">(LinkList *L, <span class="keyword">int</span> place, ElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (place &lt; <span class="number">1</span> || *L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; place &amp;&amp; p != <span class="literal">NULL</span>; i++) {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    LinkList deleteItem = p-&gt;next;</span><br><span class="line">    *e = deleteItem-&gt;data;</span><br><span class="line"></span><br><span class="line">    p-&gt;next = deleteItem-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (deleteItem-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">        deleteItem-&gt;next-&gt;prior = p;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(deleteItem);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>删除指定元素</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListDeleteValue</span><span class="params">(LinkList *L, ElemType value)</span> </span>{</span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == value) {</span><br><span class="line">            p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">                p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="双向链表的查找"><a href="#双向链表的查找" class="headerlink" title="双向链表的查找"></a>双向链表的查找</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType value)</span> </span>{</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == value) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="双向链表的遍历输出"><a href="#双向链表的遍历输出" class="headerlink" title="双向链表的遍历输出"></a>双向链表的遍历输出</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseLinkList</span><span class="params">(LinkList L)</span> </span>{</span><br><span class="line">    LinkList temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打印的双向链表为空!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (temp) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d_%d_%d  "</span>, temp-&gt;prior ? temp-&gt;prior-&gt;data : <span class="number">-1</span>, temp-&gt;data, temp-&gt;next ? temp-&gt;next-&gt;data : <span class="number">-1</span>);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h1><hr><p>双向循环链表和双向链表的唯一区别在于循环，尾结点的next指针会指向头结点，头结点的prior指针会指向尾结点</p><h2 id="双向循环链表的创建"><a href="#双向循环链表的创建" class="headerlink" title="双向循环链表的创建"></a>双向循环链表的创建</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateLinkList</span><span class="params">(LinkList *L)</span> </span>{</span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*L)-&gt;next = *L;</span><br><span class="line">    (*L)-&gt;prior = *L;</span><br><span class="line">    (*L)-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">15</span>; i++) {</span><br><span class="line">        LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">        temp-&gt;data = i;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        temp-&gt;prior = p;</span><br><span class="line">        temp-&gt;next = (*L);</span><br><span class="line">        </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="双向循环链表插入"><a href="#双向循环链表插入" class="headerlink" title="双向循环链表插入"></a>双向循环链表插入</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListInsert</span><span class="params">(LinkList *L, <span class="keyword">int</span> place, ElemType num)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (place &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    LinkList p = *L;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; place &amp;&amp; p-&gt;next != *L) {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &gt; place) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    temp-&gt;data = num;</span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != *L) {</span><br><span class="line">        temp-&gt;next-&gt;prior = temp;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        (*L)-&gt;prior = temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="双向循环链表的删除"><a href="#双向循环链表的删除" class="headerlink" title="双向循环链表的删除"></a>双向循环链表的删除</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListDelete</span><span class="params">(LinkList *L, <span class="keyword">int</span> place, ElemType *e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (place &lt; <span class="number">1</span> || *L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LinkList p = (*L)-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == *L) {</span><br><span class="line">        <span class="built_in">free</span>(*L);</span><br><span class="line">        *L = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; place &amp;&amp; p-&gt;next != *L) {</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &gt; place) <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line"></span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-单向循环链表</title>
      <link href="/posts/99fb80ac/"/>
      <url>/posts/99fb80ac/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>链表是线性表，包括两个部分：数据域、指针域；</p><ul><li>数据域：存储需要保存的数据</li><li>指针域：各个节点之间的连接</li><li>连续性：链表在逻辑上是连续的，但物理上未必连续</li></ul><p>链表主要有单向链表，双向链表，循环链表</p><h1 id="单向链表与单向循环链表对比："><a href="#单向链表与单向循环链表对比：" class="headerlink" title="单向链表与单向循环链表对比："></a>单向链表与单向循环链表对比：</h1><ul><li><p>单向链表<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-90af6e397127685e.gif?imageMogr2/auto-orient/strip" alt="2020-04-03 13.52.57.gif"></p></li><li><p>单向循环链表<br><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-7afdfcc1fb6498ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20200403-135743.png"></p></li></ul><p>与单向链表区别之处在于单向链表的最后的结点的指针域 next 是设置为 null. 但是单向循环链表最后一个结点是重新指向它的第一个首元结点的位置;</p><h1 id="单向循环链表结构体设计"><a href="#单向循环链表结构体设计" class="headerlink" title="单向循环链表结构体设计"></a>单向循环链表结构体设计</h1><hr><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="单向链表的创建"><a href="#单向链表的创建" class="headerlink" title="单向链表的创建"></a>单向链表的创建</h1><p>判断是否是第一次创建链表：</p><ul><li>YES：创建一个新结点,并使得新结点的next 指向自身；</li><li>NO：找链表尾结点,将尾结点的next指向新结点. 新结点的next指向(*L);<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateLinkList</span><span class="params">(LinkList *L)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    LinkList temp = <span class="literal">NULL</span>;</span><br><span class="line">    LinkList target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter the value of the node and end when you enter 0\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;item);</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) {</span><br><span class="line">            *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">if</span> (!L) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            (*L)-&gt;data = item;</span><br><span class="line">            (*L)-&gt;next = *L;</span><br><span class="line">            target = *L;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">            temp-&gt;data = item;</span><br><span class="line">            temp-&gt;next = *L;</span><br><span class="line">            target-&gt;next = temp;</span><br><span class="line">            target = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="单向循环链表-—-插入"><a href="#单向循环链表-—-插入" class="headerlink" title="单向循环链表 —- 插入"></a>单向循环链表 —- 插入</h1><p>插入数据， 需要注意插入的位置是否在首元结点上。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListInsert</span><span class="params">(LinkList *L, <span class="keyword">int</span> place, <span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">    LinkList temp = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    temp-&gt;data = num;</span><br><span class="line">    </span><br><span class="line">    LinkList target;</span><br><span class="line">    <span class="keyword">if</span> (place == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);</span><br><span class="line">        temp-&gt;next = *L;</span><br><span class="line">        target-&gt;next = temp;</span><br><span class="line">        *L = temp;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (target = *L, i = <span class="number">1</span>; target-&gt;next != *L &amp;&amp; i != place - <span class="number">1</span>; target = target-&gt;next, i++);</span><br><span class="line">        temp-&gt;next = target-&gt;next;</span><br><span class="line">        target-&gt;next = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="单向循环链表-—-删除"><a href="#单向循环链表-—-删除" class="headerlink" title="单向循环链表 —- 删除"></a>单向循环链表 —- 删除</h1><p>需要考虑的情况：</p><ul><li>删除的位置在首元结点上；</li><li>链表只剩下一个节点时；</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListDelete</span><span class="params">(LinkList *L, <span class="keyword">int</span> place)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    LinkList temp, target;</span><br><span class="line">    <span class="keyword">if</span> (place == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span> ((*L)-&gt;next == *L) {</span><br><span class="line">            *L = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (target = *L; target-&gt;next != *L; target = target-&gt;next);</span><br><span class="line">        temp = *L;</span><br><span class="line">        *L = (*L)-&gt;next;</span><br><span class="line">        target-&gt;next = *L;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (target = *L, i = <span class="number">1</span>; target-&gt;next != *L &amp;&amp; i != place - <span class="number">1</span>; target = target-&gt;next, i++);</span><br><span class="line">        temp = target-&gt;next;</span><br><span class="line">        target-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="单向循环链表-—-查询"><a href="#单向循环链表-—-查询" class="headerlink" title="单向循环链表 —- 查询"></a>单向循环链表 —- 查询</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(LinkList L, <span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;data != value &amp;&amp; p-&gt;next != L) {</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == L &amp;&amp; p-&gt;data != value) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Demo：<a href="https://github.com/ShoukaiWang/DataStructuresAndAlgorithms" target="_blank" rel="noopener">https://github.com/ShoukaiWang/DataStructuresAndAlgorithms</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础</title>
      <link href="/posts/3b4e48c8/"/>
      <url>/posts/3b4e48c8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构：是指相互之间存在一种或多种特定关系的数据元素的集合用计算机存储、组织数据的方式。数据结构分别为逻辑结构、（存储）物理结构和数据的运算三个部分。</p><h2 id="1-1-概念术语"><a href="#1-1-概念术语" class="headerlink" title="1.1. 概念术语"></a>1.1. 概念术语</h2><ul><li>数据（Data）是能被计算机处理的符号或符号集合</li><li>数据元素（data element）是数据的基本单位</li><li>数据项（data item）组成数据元素的最小单位</li><li>数据对象（data object）是性质相同的数据元素的集合，是数据的一个子集</li><li>数据结构（data structure）是数据的组织形式，数据元素之间存在的一种或多种特定关系的数据元素集合</li><li>数据类型（data type）是按照数据值的不同进行划分的可操作性。在C语言中还可以分为原子类型和结构类型。原字类型是不可以再分解的基本类型，包括整型、实型、字符型等。结构类型是由若干个类型组合而成，是可以再分解的</li></ul><h2 id="1-2-逻辑结构"><a href="#1-2-逻辑结构" class="headerlink" title="1.2. 逻辑结构"></a>1.2. 逻辑结构</h2><ul><li>集合结构：集合的数据元素没有其他关系，仅仅是因为他们挤在一个被称作“集合”的盒子里。</li><li>线性结构：线性的数据元素结构关系是一对一的，并且是一种先后的次序</li><li>树形结构：树形的数据元素结构关系是一对多的</li><li>图形结构：图的数据元素结构关系是多对多的<br>##1.3. 数据存储结构<blockquote><p>存储结构（storage structure）也称为物理结构（physical structure），指的是数据的逻辑结构在计算机中的存储形式。数据的存储结构一般可以反映数据元素之间的逻辑关系</p></blockquote></li><li>顺序存储结构：是把数据元素存放在一组存储地址连续的存储单元里，其数据元素间的逻辑关系和物理关系是一致的</li><li>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的，数据元素的存储关系并不能反映其逻辑关系，因此需要借助指针来表示数据元素之间的逻辑关系<blockquote><p>总结 逻辑结构是面向问题的,而物理结构就是面向计算机的. 其基本的目标就是将数据以及逻辑关系存储到计算机的内存中.</p></blockquote></li></ul><h2 id="1-4-抽象数据类型"><a href="#1-4-抽象数据类型" class="headerlink" title="1.4. 抽象数据类型"></a>1.4. 抽象数据类型</h2><h3 id="1-4-1-数据类型"><a href="#1-4-1-数据类型" class="headerlink" title="1.4.1 数据类型"></a>1.4.1 数据类型</h3><p>数据类型: 是指一组性质相同值的集合以及定义在此集合的一些操作的总称。在C语言中,按照取值不同,数据类型可以分为2类:</p><ul><li>原子类型: 是不可以在分解的基本数据类型,包含整型,浮点型,字符型等;</li><li>结构类型: 由若干类型组合而成,是可以再分解的.例如,整型数组就是由若干整型数据组成的.</li></ul><h3 id="1-4-2-抽象数据类型"><a href="#1-4-2-抽象数据类型" class="headerlink" title="1.4.2 抽象数据类型"></a>1.4.2 抽象数据类型</h3><p>抽象数据类型（abstract data type，ADT）是描述具有某种逻辑关系的数据模型，并对在数学模型上进行的一组操作。抽象数据类型描述的是一组逻辑上的特性，与在计算机内部表示无关，计算机中的整数数据类型是一个抽象数据类型，不同处理器可能实现方法不同，但其逻辑特性相同，即加、减、乘、除等运算是一致的。“抽象”的意思是数据类型的数学抽象特性而不是指它们的实现方法。抽象数据类型体现了程序设计中的问题分解、抽象、信息隐藏等特性，可以把现实中的大问题分解为多个规模小且容易处理的小问题，然后建立起一个能被计算机处理的数据，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。就类似建一栋房子，分成若干个小任务，如地皮规划、图纸设计、施工、装修等，整个过程与抽象数据类型中的问题分解类似。而搬砖人不需要了解图纸设计如何，设计图纸人员不需要了解施工的地基、砌墙的具体细节，装修工人不用关系图纸和搬砖过程，这就是抽象类型中的信息隐藏。<br>      抽象数据类型的概念可能让初学者不太容易理解。例如线性表的抽象数据类型的描述数据对象集合：线性表的数据对象集合为{a1,a2,a3,····,an},每个元素的类型均为DataType。其中，除了第一个元素a1外，每一个元素有且只有一个直接前驱元素；除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的。</p><h2 id="1-5算法"><a href="#1-5算法" class="headerlink" title="1.5算法"></a>1.5算法</h2><p>算法（algorithm）是解决特定问题求解步骤的描述，在计算机中表现为有限的操作序列。在数据类型建立起来之后，就要对这些数据类型进行操作，建立起运算的集合即程序。运算的建立、方法好坏直接决定着计算机程序原型效率的高低。<br>###1.5.1. 数据结构和算法的关系<br>两者基友联系又有区别。联系是程序=算法+数据结构。数据结构是算法实现的基础，算法总是要依赖某种数据结构来实现的。算法的操作对象是数据结构。区别是数据结构关注的是数据的逻辑结构、存储结构有一集基本操作，而算法更多的是关注如何在数据结构的基本上解决实际问题。算法是编程思想，数据结构则是这些思想的基础。</p><h3 id="1-5-2-特性"><a href="#1-5-2-特性" class="headerlink" title="1.5.2. 特性"></a>1.5.2. 特性</h3><ul><li>输入</li><li>输出</li><li>有穷性: 指的是算法在执行有限的步骤之后,自动结束而不会出现无限循环,且每一个步骤在可接受的时间内完成.</li><li>确定性: 算法的每一个步骤都具有确定的含义,不能出现二义性; 算法在一定条件下,只有一条执行路径,相同的输入只能有唯一的输出结果.</li><li>可行性<br>###1.5.3. 算法设计要求</li><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高和存储量低</li></ul><h2 id="1-6-时间复杂度"><a href="#1-6-时间复杂度" class="headerlink" title="1.6. 时间复杂度"></a>1.6. 时间复杂度</h2><p>时间复杂度，又称时间复杂性，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。时间复杂度常用大O符号表述。</p><p>为了更好地描述时间复杂度有以下规定：</p><ul><li>所有的常数时间复杂度用1表示。</li><li>只保留最高阶的时间复杂度。</li><li>去除最高阶时间复杂度的系数。</li></ul><p>算法的时间复杂度是衡量一个算法好坏的重要指标。一般情况下，随着规模n的增大，次数T(n)的增长较慢的算法为最优算法。常见时间复杂度从小到大依次排列：</p><blockquote><p>O(1) &lt; O(logn) &lt; O(n)&lt; O(nlogn) &lt; O(n²）&lt;O(n³) &lt; O(2^n) &lt;O(n!) &lt; O(n^n)<br>###常见的时间复杂度</p></blockquote><ul><li>常数阶</li><li>线性阶</li><li>对数阶</li><li>平方阶</li><li>立方阶</li><li>nlogn阶</li><li>指数阶</li></ul><p><img src= "/img/loading.gif" data-src="medias/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/533739-2e3042c177bc27d9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1712e87e09c320a9.jpeg"></p><blockquote><p>时间复杂度描述的是算法的最坏情况。</p></blockquote><h2 id="1-7-空间复杂度"><a href="#1-7-空间复杂度" class="headerlink" title="1.7 空间复杂度"></a>1.7 空间复杂度</h2><p>空间复杂度（space complexity）作为算法所需存储空间的量度，记做S(n) = O (f(n))。其中，n为问题的规模；f（n）为语句关于n的所占存储空间的函数。<br>对于一个算法，所有的变量、指令、结果都需要存储空间，另外在算法的执行过程中，临时变量和临时结果也需要保留下来以便下一步计算，这些称为算法执行时的辅助空间。</p><blockquote><p>空间复杂度主要定性描述算法所需的辅助空间。</p></blockquote><p>对一个算法,其时间复杂度和空间复杂度往往会互相影响. 当追求一个较好的时间空间复杂度时,可能会导致占用较多的存储空间. 即可能会使用空间复杂度的性能变差.反之亦然. 不过,通常情况下,鉴于运算空间较为充足,人们都以算法时间空间复杂度作为算法优先的衡量指标。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataStructures &amp; Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
